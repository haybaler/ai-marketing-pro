"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@mendable";
exports.ids = ["vendor-chunks/@mendable"];
exports.modules = {

/***/ "(rsc)/./node_modules/@mendable/firecrawl-js/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@mendable/firecrawl-js/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CrawlWatcher: () => (/* binding */ CrawlWatcher),\n/* harmony export */   FirecrawlError: () => (/* binding */ FirecrawlError),\n/* harmony export */   \"default\": () => (/* binding */ FirecrawlApp)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/index.js\");\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/v3/types.js\");\n/* harmony import */ var zod_to_json_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zod-to-json-schema */ \"(rsc)/./node_modules/zod-to-json-schema/dist/esm/index.js\");\n/* harmony import */ var isows__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! isows */ \"(rsc)/./node_modules/isows/_esm/index.js\");\n/* harmony import */ var typescript_event_target__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! typescript-event-target */ \"(rsc)/./node_modules/typescript-event-target/dist/index.mjs\");\n// src/index.ts\n\n\n\n\n\nvar FirecrawlError = class extends Error {\n  statusCode;\n  details;\n  constructor(message, statusCode, details) {\n    super(message);\n    this.statusCode = statusCode;\n    this.details = details;\n  }\n};\nvar FirecrawlApp = class {\n  apiKey;\n  apiUrl;\n  isCloudService(url) {\n    return url.includes(\"api.firecrawl.dev\");\n  }\n  /**\n   * Initializes a new instance of the FirecrawlApp class.\n   * @param config - Configuration options for the FirecrawlApp instance.\n   */\n  constructor({ apiKey = null, apiUrl = null }) {\n    const baseUrl = apiUrl || \"https://api.firecrawl.dev\";\n    if (this.isCloudService(baseUrl) && typeof apiKey !== \"string\") {\n      throw new FirecrawlError(\"No API key provided\", 401);\n    }\n    this.apiKey = apiKey || \"\";\n    this.apiUrl = baseUrl;\n  }\n  /**\n   * Scrapes a URL using the Firecrawl API.\n   * @param url - The URL to scrape.\n   * @param params - Additional parameters for the scrape request.\n   * @returns The response from the scrape operation.\n   */\n  async scrapeUrl(url, params) {\n    const headers = {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${this.apiKey}`\n    };\n    let jsonData = { url, ...params };\n    if (jsonData?.extract?.schema) {\n      let schema = jsonData.extract.schema;\n      try {\n        schema = (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_0__.zodToJsonSchema)(schema);\n      } catch (error) {\n      }\n      jsonData = {\n        ...jsonData,\n        extract: {\n          ...jsonData.extract,\n          schema\n        }\n      };\n    }\n    if (jsonData?.jsonOptions?.schema) {\n      let schema = jsonData.jsonOptions.schema;\n      try {\n        schema = (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_0__.zodToJsonSchema)(schema);\n      } catch (error) {\n      }\n      jsonData = {\n        ...jsonData,\n        jsonOptions: {\n          ...jsonData.jsonOptions,\n          schema\n        }\n      };\n    }\n    try {\n      const response = await axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].post(\n        this.apiUrl + `/v1/scrape`,\n        jsonData,\n        { headers, timeout: params?.timeout !== void 0 ? params.timeout + 5e3 : void 0 }\n      );\n      if (response.status === 200) {\n        const responseData = response.data;\n        if (responseData.success) {\n          return {\n            success: true,\n            warning: responseData.warning,\n            error: responseData.error,\n            ...responseData.data\n          };\n        } else {\n          throw new FirecrawlError(`Failed to scrape URL. Error: ${responseData.error}`, response.status);\n        }\n      } else {\n        this.handleError(response, \"scrape URL\");\n      }\n    } catch (error) {\n      this.handleError(error.response, \"scrape URL\");\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Searches using the Firecrawl API and optionally scrapes the results.\n   * @param query - The search query string.\n   * @param params - Optional parameters for the search request.\n   * @returns The response from the search operation.\n   */\n  async search(query, params) {\n    const headers = {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${this.apiKey}`\n    };\n    let jsonData = {\n      query,\n      limit: params?.limit ?? 5,\n      tbs: params?.tbs,\n      filter: params?.filter,\n      lang: params?.lang ?? \"en\",\n      country: params?.country ?? \"us\",\n      location: params?.location,\n      origin: params?.origin ?? \"api\",\n      timeout: params?.timeout ?? 6e4,\n      scrapeOptions: params?.scrapeOptions ?? { formats: [] }\n    };\n    if (jsonData?.scrapeOptions?.extract?.schema) {\n      let schema = jsonData.scrapeOptions.extract.schema;\n      try {\n        schema = (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_0__.zodToJsonSchema)(schema);\n      } catch (error) {\n      }\n      jsonData = {\n        ...jsonData,\n        scrapeOptions: {\n          ...jsonData.scrapeOptions,\n          extract: {\n            ...jsonData.scrapeOptions.extract,\n            schema\n          }\n        }\n      };\n    }\n    try {\n      const response = await this.postRequest(\n        this.apiUrl + `/v1/search`,\n        jsonData,\n        headers\n      );\n      if (response.status === 200) {\n        const responseData = response.data;\n        if (responseData.success) {\n          return {\n            success: true,\n            data: responseData.data,\n            warning: responseData.warning\n          };\n        } else {\n          throw new FirecrawlError(`Failed to search. Error: ${responseData.error}`, response.status);\n        }\n      } else {\n        this.handleError(response, \"search\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\", data: [] };\n  }\n  /**\n   * Initiates a crawl job for a URL using the Firecrawl API.\n   * @param url - The URL to crawl.\n   * @param params - Additional parameters for the crawl request.\n   * @param pollInterval - Time in seconds for job status checks.\n   * @param idempotencyKey - Optional idempotency key for the request.\n   * @returns The response from the crawl operation.\n   */\n  async crawlUrl(url, params, pollInterval = 2, idempotencyKey) {\n    const headers = this.prepareHeaders(idempotencyKey);\n    let jsonData = { url, ...params };\n    try {\n      const response = await this.postRequest(\n        this.apiUrl + `/v1/crawl`,\n        jsonData,\n        headers\n      );\n      if (response.status === 200) {\n        const id = response.data.id;\n        return this.monitorJobStatus(id, headers, pollInterval);\n      } else {\n        this.handleError(response, \"start crawl job\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  async asyncCrawlUrl(url, params, idempotencyKey) {\n    const headers = this.prepareHeaders(idempotencyKey);\n    let jsonData = { url, ...params };\n    try {\n      const response = await this.postRequest(\n        this.apiUrl + `/v1/crawl`,\n        jsonData,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"start crawl job\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Checks the status of a crawl job using the Firecrawl API.\n   * @param id - The ID of the crawl operation.\n   * @param getAllData - Paginate through all the pages of documents, returning the full list of all documents. (default: `false`)\n   * @param nextURL - The `next` URL from the previous crawl status. Only required if you're not manually increasing `skip`. Only used when `getAllData = false`.\n   * @param skip - How many entries to skip to paginate. Only required if you're not providing `nextURL`. Only used when `getAllData = false`.\n   * @param limit - How many entries to return. Only used when `getAllData = false`.\n   * @returns The response containing the job status.\n   */\n  async checkCrawlStatus(id, getAllData = false, nextURL, skip, limit) {\n    if (!id) {\n      throw new FirecrawlError(\"No crawl ID provided\", 400);\n    }\n    const headers = this.prepareHeaders();\n    const targetURL = new URL(nextURL ?? `${this.apiUrl}/v1/crawl/${id}`);\n    if (skip !== void 0) {\n      targetURL.searchParams.set(\"skip\", skip.toString());\n    }\n    if (limit !== void 0) {\n      targetURL.searchParams.set(\"limit\", limit.toString());\n    }\n    try {\n      const response = await this.getRequest(\n        targetURL.href,\n        headers\n      );\n      if (response.status === 200) {\n        let allData = response.data.data;\n        if (getAllData && response.data.status === \"completed\") {\n          let statusData = response.data;\n          if (\"data\" in statusData) {\n            let data = statusData.data;\n            while (typeof statusData === \"object\" && \"next\" in statusData) {\n              if (data.length === 0) {\n                break;\n              }\n              statusData = (await this.getRequest(statusData.next, headers)).data;\n              data = data.concat(statusData.data);\n            }\n            allData = data;\n          }\n        }\n        let resp = {\n          success: response.data.success,\n          status: response.data.status,\n          total: response.data.total,\n          completed: response.data.completed,\n          creditsUsed: response.data.creditsUsed,\n          next: getAllData ? void 0 : response.data.next,\n          expiresAt: new Date(response.data.expiresAt),\n          data: allData\n        };\n        if (!response.data.success && response.data.error) {\n          resp = {\n            ...resp,\n            success: false,\n            error: response.data.error\n          };\n        }\n        if (response.data.next) {\n          resp.next = response.data.next;\n        }\n        return resp;\n      } else {\n        this.handleError(response, \"check crawl status\");\n      }\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500);\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Returns information about crawl errors.\n   * @param id - The ID of the crawl operation.\n   * @returns Information about crawl errors.\n   */\n  async checkCrawlErrors(id) {\n    const headers = this.prepareHeaders();\n    try {\n      const response = await this.deleteRequest(\n        `${this.apiUrl}/v1/crawl/${id}/errors`,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"check crawl errors\");\n      }\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500);\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Cancels a crawl job using the Firecrawl API.\n   * @param id - The ID of the crawl operation.\n   * @returns The response from the cancel crawl operation.\n   */\n  async cancelCrawl(id) {\n    const headers = this.prepareHeaders();\n    try {\n      const response = await this.deleteRequest(\n        `${this.apiUrl}/v1/crawl/${id}`,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"cancel crawl job\");\n      }\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500);\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Initiates a crawl job and returns a CrawlWatcher to monitor the job via WebSocket.\n   * @param url - The URL to crawl.\n   * @param params - Additional parameters for the crawl request.\n   * @param idempotencyKey - Optional idempotency key for the request.\n   * @returns A CrawlWatcher instance to monitor the crawl job.\n   */\n  async crawlUrlAndWatch(url, params, idempotencyKey) {\n    const crawl = await this.asyncCrawlUrl(url, params, idempotencyKey);\n    if (crawl.success && crawl.id) {\n      const id = crawl.id;\n      return new CrawlWatcher(id, this);\n    }\n    throw new FirecrawlError(\"Crawl job failed to start\", 400);\n  }\n  /**\n   * Maps a URL using the Firecrawl API.\n   * @param url - The URL to map.\n   * @param params - Additional parameters for the map request.\n   * @returns The response from the map operation.\n   */\n  async mapUrl(url, params) {\n    const headers = this.prepareHeaders();\n    let jsonData = { url, ...params };\n    try {\n      const response = await this.postRequest(\n        this.apiUrl + `/v1/map`,\n        jsonData,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"map\");\n      }\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500);\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Initiates a batch scrape job for multiple URLs using the Firecrawl API.\n   * @param url - The URLs to scrape.\n   * @param params - Additional parameters for the scrape request.\n   * @param pollInterval - Time in seconds for job status checks.\n   * @param idempotencyKey - Optional idempotency key for the request.\n   * @param webhook - Optional webhook for the batch scrape.\n   * @param ignoreInvalidURLs - Optional flag to ignore invalid URLs.\n   * @returns The response from the crawl operation.\n   */\n  async batchScrapeUrls(urls, params, pollInterval = 2, idempotencyKey, webhook, ignoreInvalidURLs) {\n    const headers = this.prepareHeaders(idempotencyKey);\n    let jsonData = { urls, webhook, ignoreInvalidURLs, ...params };\n    if (jsonData?.extract?.schema) {\n      let schema = jsonData.extract.schema;\n      try {\n        schema = (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_0__.zodToJsonSchema)(schema);\n      } catch (error) {\n      }\n      jsonData = {\n        ...jsonData,\n        extract: {\n          ...jsonData.extract,\n          schema\n        }\n      };\n    }\n    if (jsonData?.jsonOptions?.schema) {\n      let schema = jsonData.jsonOptions.schema;\n      try {\n        schema = (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_0__.zodToJsonSchema)(schema);\n      } catch (error) {\n      }\n      jsonData = {\n        ...jsonData,\n        jsonOptions: {\n          ...jsonData.jsonOptions,\n          schema\n        }\n      };\n    }\n    try {\n      const response = await this.postRequest(\n        this.apiUrl + `/v1/batch/scrape`,\n        jsonData,\n        headers\n      );\n      if (response.status === 200) {\n        const id = response.data.id;\n        return this.monitorJobStatus(id, headers, pollInterval);\n      } else {\n        this.handleError(response, \"start batch scrape job\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  async asyncBatchScrapeUrls(urls, params, idempotencyKey, webhook, ignoreInvalidURLs) {\n    const headers = this.prepareHeaders(idempotencyKey);\n    let jsonData = { urls, webhook, ignoreInvalidURLs, ...params ?? {} };\n    try {\n      const response = await this.postRequest(\n        this.apiUrl + `/v1/batch/scrape`,\n        jsonData,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"start batch scrape job\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Initiates a batch scrape job and returns a CrawlWatcher to monitor the job via WebSocket.\n   * @param urls - The URL to scrape.\n   * @param params - Additional parameters for the scrape request.\n   * @param idempotencyKey - Optional idempotency key for the request.\n   * @returns A CrawlWatcher instance to monitor the crawl job.\n   */\n  async batchScrapeUrlsAndWatch(urls, params, idempotencyKey, webhook, ignoreInvalidURLs) {\n    const crawl = await this.asyncBatchScrapeUrls(urls, params, idempotencyKey, webhook, ignoreInvalidURLs);\n    if (crawl.success && crawl.id) {\n      const id = crawl.id;\n      return new CrawlWatcher(id, this);\n    }\n    throw new FirecrawlError(\"Batch scrape job failed to start\", 400);\n  }\n  /**\n   * Checks the status of a batch scrape job using the Firecrawl API.\n   * @param id - The ID of the batch scrape operation.\n   * @param getAllData - Paginate through all the pages of documents, returning the full list of all documents. (default: `false`)\n   * @param nextURL - The `next` URL from the previous batch scrape status. Only required if you're not manually increasing `skip`. Only used when `getAllData = false`.\n   * @param skip - How many entries to skip to paginate. Only used when `getAllData = false`.\n   * @param limit - How many entries to return. Only used when `getAllData = false`.\n   * @returns The response containing the job status.\n   */\n  async checkBatchScrapeStatus(id, getAllData = false, nextURL, skip, limit) {\n    if (!id) {\n      throw new FirecrawlError(\"No batch scrape ID provided\", 400);\n    }\n    const headers = this.prepareHeaders();\n    const targetURL = new URL(nextURL ?? `${this.apiUrl}/v1/batch/scrape/${id}`);\n    if (skip !== void 0) {\n      targetURL.searchParams.set(\"skip\", skip.toString());\n    }\n    if (limit !== void 0) {\n      targetURL.searchParams.set(\"limit\", limit.toString());\n    }\n    try {\n      const response = await this.getRequest(\n        targetURL.href,\n        headers\n      );\n      if (response.status === 200) {\n        let allData = response.data.data;\n        if (getAllData && response.data.status === \"completed\") {\n          let statusData = response.data;\n          if (\"data\" in statusData) {\n            let data = statusData.data;\n            while (typeof statusData === \"object\" && \"next\" in statusData) {\n              if (data.length === 0) {\n                break;\n              }\n              statusData = (await this.getRequest(statusData.next, headers)).data;\n              data = data.concat(statusData.data);\n            }\n            allData = data;\n          }\n        }\n        let resp = {\n          success: response.data.success,\n          status: response.data.status,\n          total: response.data.total,\n          completed: response.data.completed,\n          creditsUsed: response.data.creditsUsed,\n          next: getAllData ? void 0 : response.data.next,\n          expiresAt: new Date(response.data.expiresAt),\n          data: allData\n        };\n        if (!response.data.success && response.data.error) {\n          resp = {\n            ...resp,\n            success: false,\n            error: response.data.error\n          };\n        }\n        if (response.data.next) {\n          resp.next = response.data.next;\n        }\n        return resp;\n      } else {\n        this.handleError(response, \"check batch scrape status\");\n      }\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500);\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Returns information about batch scrape errors.\n   * @param id - The ID of the batch scrape operation.\n   * @returns Information about batch scrape errors.\n   */\n  async checkBatchScrapeErrors(id) {\n    const headers = this.prepareHeaders();\n    try {\n      const response = await this.deleteRequest(\n        `${this.apiUrl}/v1/batch/scrape/${id}/errors`,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"check batch scrape errors\");\n      }\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500);\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Extracts information from URLs using the Firecrawl API.\n   * Currently in Beta. Expect breaking changes on future minor versions.\n   * @param urls - The URLs to extract information from. Optional if using other methods for data extraction.\n   * @param params - Additional parameters for the extract request.\n   * @returns The response from the extract operation.\n   */\n  async extract(urls, params) {\n    const headers = this.prepareHeaders();\n    let jsonData = { urls, ...params };\n    let jsonSchema;\n    try {\n      if (!params?.schema) {\n        jsonSchema = void 0;\n      } else if (typeof params.schema === \"object\" && params.schema !== null && Object.getPrototypeOf(params.schema)?.constructor?.name?.startsWith(\"Zod\")) {\n        jsonSchema = (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_0__.zodToJsonSchema)(params.schema);\n      } else {\n        jsonSchema = params.schema;\n      }\n    } catch (error) {\n      throw new FirecrawlError(\"Invalid schema. Schema must be either a valid Zod schema or JSON schema object.\", 400);\n    }\n    try {\n      const response = await this.postRequest(\n        this.apiUrl + `/v1/extract`,\n        { ...jsonData, schema: jsonSchema, origin: params?.origin || \"api-sdk\" },\n        headers\n      );\n      if (response.status === 200) {\n        const jobId = response.data.id;\n        let extractStatus;\n        do {\n          const statusResponse = await this.getRequest(\n            `${this.apiUrl}/v1/extract/${jobId}`,\n            headers\n          );\n          extractStatus = statusResponse.data;\n          if (extractStatus.status === \"completed\") {\n            if (extractStatus.success) {\n              return {\n                success: true,\n                data: extractStatus.data,\n                warning: extractStatus.warning,\n                error: extractStatus.error,\n                sources: extractStatus?.sources || void 0\n              };\n            } else {\n              throw new FirecrawlError(`Failed to extract data. Error: ${extractStatus.error}`, statusResponse.status);\n            }\n          } else if (extractStatus.status === \"failed\" || extractStatus.status === \"cancelled\") {\n            throw new FirecrawlError(`Extract job ${extractStatus.status}. Error: ${extractStatus.error}`, statusResponse.status);\n          }\n          await new Promise((resolve) => setTimeout(resolve, 1e3));\n        } while (extractStatus.status !== \"completed\");\n      } else {\n        this.handleError(response, \"extract\");\n      }\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500, error.response?.data?.details);\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Initiates an asynchronous extract job for a URL using the Firecrawl API.\n   * @param url - The URL to extract data from.\n   * @param params - Additional parameters for the extract request.\n   * @param idempotencyKey - Optional idempotency key for the request.\n   * @returns The response from the extract operation.\n   */\n  async asyncExtract(urls, params, idempotencyKey) {\n    const headers = this.prepareHeaders(idempotencyKey);\n    let jsonData = { urls, ...params };\n    let jsonSchema;\n    try {\n      if (params?.schema instanceof zod__WEBPACK_IMPORTED_MODULE_3__.ZodType) {\n        jsonSchema = (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_0__.zodToJsonSchema)(params.schema);\n      } else {\n        jsonSchema = params?.schema;\n      }\n    } catch (error) {\n      throw new FirecrawlError(\"Invalid schema. Schema must be either a valid Zod schema or JSON schema object.\", 400);\n    }\n    try {\n      const response = await this.postRequest(\n        this.apiUrl + `/v1/extract`,\n        { ...jsonData, schema: jsonSchema },\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"start extract job\");\n      }\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500, error.response?.data?.details);\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Retrieves the status of an extract job.\n   * @param jobId - The ID of the extract job.\n   * @returns The status of the extract job.\n   */\n  async getExtractStatus(jobId) {\n    try {\n      const response = await this.getRequest(\n        `${this.apiUrl}/v1/extract/${jobId}`,\n        this.prepareHeaders()\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"get extract status\");\n      }\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500);\n    }\n  }\n  /**\n   * Prepares the headers for an API request.\n   * @param idempotencyKey - Optional key to ensure idempotency.\n   * @returns The prepared headers.\n   */\n  prepareHeaders(idempotencyKey) {\n    return {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${this.apiKey}`,\n      ...idempotencyKey ? { \"x-idempotency-key\": idempotencyKey } : {}\n    };\n  }\n  /**\n   * Sends a POST request to the specified URL.\n   * @param url - The URL to send the request to.\n   * @param data - The data to send in the request.\n   * @param headers - The headers for the request.\n   * @returns The response from the POST request.\n   */\n  postRequest(url, data, headers) {\n    return axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].post(url, data, { headers, timeout: data?.timeout ? data.timeout + 5e3 : void 0 });\n  }\n  /**\n   * Sends a GET request to the specified URL.\n   * @param url - The URL to send the request to.\n   * @param headers - The headers for the request.\n   * @returns The response from the GET request.\n   */\n  async getRequest(url, headers) {\n    try {\n      return await axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get(url, { headers });\n    } catch (error) {\n      if (error instanceof axios__WEBPACK_IMPORTED_MODULE_4__.AxiosError && error.response) {\n        return error.response;\n      } else {\n        throw error;\n      }\n    }\n  }\n  /**\n   * Sends a DELETE request to the specified URL.\n   * @param url - The URL to send the request to.\n   * @param headers - The headers for the request.\n   * @returns The response from the DELETE request.\n   */\n  async deleteRequest(url, headers) {\n    try {\n      return await axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].delete(url, { headers });\n    } catch (error) {\n      if (error instanceof axios__WEBPACK_IMPORTED_MODULE_4__.AxiosError && error.response) {\n        return error.response;\n      } else {\n        throw error;\n      }\n    }\n  }\n  /**\n   * Monitors the status of a crawl job until completion or failure.\n   * @param id - The ID of the crawl operation.\n   * @param headers - The headers for the request.\n   * @param checkInterval - Interval in seconds for job status checks.\n   * @param checkUrl - Optional URL to check the status (used for v1 API)\n   * @returns The final job status or data.\n   */\n  async monitorJobStatus(id, headers, checkInterval) {\n    try {\n      let failedTries = 0;\n      while (true) {\n        let statusResponse = await this.getRequest(\n          `${this.apiUrl}/v1/crawl/${id}`,\n          headers\n        );\n        if (statusResponse.status === 200) {\n          failedTries = 0;\n          let statusData = statusResponse.data;\n          if (statusData.status === \"completed\") {\n            if (\"data\" in statusData) {\n              let data = statusData.data;\n              while (typeof statusData === \"object\" && \"next\" in statusData) {\n                if (data.length === 0) {\n                  break;\n                }\n                statusResponse = await this.getRequest(statusData.next, headers);\n                statusData = statusResponse.data;\n                data = data.concat(statusData.data);\n              }\n              statusData.data = data;\n              return statusData;\n            } else {\n              throw new FirecrawlError(\"Crawl job completed but no data was returned\", 500);\n            }\n          } else if ([\"active\", \"paused\", \"pending\", \"queued\", \"waiting\", \"scraping\"].includes(statusData.status)) {\n            checkInterval = Math.max(checkInterval, 2);\n            await new Promise(\n              (resolve) => setTimeout(resolve, checkInterval * 1e3)\n            );\n          } else {\n            throw new FirecrawlError(\n              `Crawl job failed or was stopped. Status: ${statusData.status}`,\n              500\n            );\n          }\n        } else {\n          failedTries++;\n          if (failedTries >= 3) {\n            this.handleError(statusResponse, \"check crawl status\");\n          }\n        }\n      }\n    } catch (error) {\n      throw new FirecrawlError(error, 500);\n    }\n  }\n  /**\n   * Handles errors from API responses.\n   * @param {AxiosResponse} response - The response from the API.\n   * @param {string} action - The action being performed when the error occurred.\n   */\n  handleError(response, action) {\n    if ([400, 402, 403, 408, 409, 500].includes(response.status)) {\n      const errorMessage = response.data.error || \"Unknown error occurred\";\n      const details = response.data.details ? ` - ${JSON.stringify(response.data.details)}` : \"\";\n      throw new FirecrawlError(\n        `Failed to ${action}. Status code: ${response.status}. Error: ${errorMessage}${details}`,\n        response.status,\n        response?.data?.details\n      );\n    } else {\n      throw new FirecrawlError(\n        `Unexpected error occurred while trying to ${action}. Status code: ${response.status}`,\n        response.status\n      );\n    }\n  }\n  /**\n   * Initiates a deep research operation on a given query and polls until completion.\n   * @param query - The query to research.\n   * @param params - Parameters for the deep research operation.\n   * @param onActivity - Optional callback to receive activity updates in real-time.\n   * @param onSource - Optional callback to receive source updates in real-time.\n   * @returns The final research results.\n   */\n  async deepResearch(query, params, onActivity, onSource) {\n    try {\n      const response = await this.asyncDeepResearch(query, params);\n      if (!response.success || \"error\" in response) {\n        return { success: false, error: \"error\" in response ? response.error : \"Unknown error\" };\n      }\n      if (!response.id) {\n        throw new FirecrawlError(`Failed to start research. No job ID returned.`, 500);\n      }\n      const jobId = response.id;\n      let researchStatus;\n      let lastActivityCount = 0;\n      let lastSourceCount = 0;\n      while (true) {\n        researchStatus = await this.checkDeepResearchStatus(jobId);\n        if (\"error\" in researchStatus && !researchStatus.success) {\n          return researchStatus;\n        }\n        if (onActivity && researchStatus.activities) {\n          const newActivities = researchStatus.activities.slice(lastActivityCount);\n          for (const activity of newActivities) {\n            onActivity(activity);\n          }\n          lastActivityCount = researchStatus.activities.length;\n        }\n        if (onSource && researchStatus.sources) {\n          const newSources = researchStatus.sources.slice(lastSourceCount);\n          for (const source of newSources) {\n            onSource(source);\n          }\n          lastSourceCount = researchStatus.sources.length;\n        }\n        if (researchStatus.status === \"completed\") {\n          return researchStatus;\n        }\n        if (researchStatus.status === \"failed\") {\n          throw new FirecrawlError(\n            `Research job ${researchStatus.status}. Error: ${researchStatus.error}`,\n            500\n          );\n        }\n        if (researchStatus.status !== \"processing\") {\n          break;\n        }\n        await new Promise((resolve) => setTimeout(resolve, 2e3));\n      }\n      return { success: false, error: \"Research job terminated unexpectedly\" };\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500, error.response?.data?.details);\n    }\n  }\n  /**\n   * Initiates a deep research operation on a given query without polling.\n   * @param params - Parameters for the deep research operation.\n   * @returns The response containing the research job ID.\n   */\n  async asyncDeepResearch(query, params) {\n    const headers = this.prepareHeaders();\n    let jsonData = { query, ...params };\n    if (jsonData?.jsonOptions?.schema) {\n      let schema = jsonData.jsonOptions.schema;\n      try {\n        schema = (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_0__.zodToJsonSchema)(schema);\n      } catch (error) {\n      }\n      jsonData = {\n        ...jsonData,\n        jsonOptions: {\n          ...jsonData.jsonOptions,\n          schema\n        }\n      };\n    }\n    try {\n      const response = await this.postRequest(\n        `${this.apiUrl}/v1/deep-research`,\n        jsonData,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"start deep research\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Checks the status of a deep research operation.\n   * @param id - The ID of the deep research operation.\n   * @returns The current status and results of the research operation.\n   */\n  async checkDeepResearchStatus(id) {\n    const headers = this.prepareHeaders();\n    try {\n      const response = await this.getRequest(\n        `${this.apiUrl}/v1/deep-research/${id}`,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else if (response.status === 404) {\n        throw new FirecrawlError(\"Deep research job not found\", 404);\n      } else {\n        this.handleError(response, \"check deep research status\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * @deprecated Use deepResearch() instead\n   * Initiates a deep research operation on a given topic and polls until completion.\n   * @param topic - The topic to research.\n   * @param params - Parameters for the deep research operation.\n   * @param onActivity - Optional callback to receive activity updates in real-time.\n   * @returns The final research results.\n   */\n  async __deepResearch(topic, params, onActivity) {\n    try {\n      const response = await this.__asyncDeepResearch(topic, params);\n      if (!response.success || \"error\" in response) {\n        return { success: false, error: \"error\" in response ? response.error : \"Unknown error\" };\n      }\n      if (!response.id) {\n        throw new FirecrawlError(`Failed to start research. No job ID returned.`, 500);\n      }\n      const jobId = response.id;\n      let researchStatus;\n      let lastActivityCount = 0;\n      while (true) {\n        researchStatus = await this.__checkDeepResearchStatus(jobId);\n        if (\"error\" in researchStatus && !researchStatus.success) {\n          return researchStatus;\n        }\n        if (onActivity && researchStatus.activities) {\n          const newActivities = researchStatus.activities.slice(lastActivityCount);\n          for (const activity of newActivities) {\n            onActivity(activity);\n          }\n          lastActivityCount = researchStatus.activities.length;\n        }\n        if (researchStatus.status === \"completed\") {\n          return researchStatus;\n        }\n        if (researchStatus.status === \"failed\") {\n          throw new FirecrawlError(\n            `Research job ${researchStatus.status}. Error: ${researchStatus.error}`,\n            500\n          );\n        }\n        if (researchStatus.status !== \"processing\") {\n          break;\n        }\n        await new Promise((resolve) => setTimeout(resolve, 2e3));\n      }\n      return { success: false, error: \"Research job terminated unexpectedly\" };\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500, error.response?.data?.details);\n    }\n  }\n  /**\n   * @deprecated Use asyncDeepResearch() instead\n   * Initiates a deep research operation on a given topic without polling.\n   * @param params - Parameters for the deep research operation.\n   * @returns The response containing the research job ID.\n   */\n  async __asyncDeepResearch(topic, params) {\n    const headers = this.prepareHeaders();\n    try {\n      const response = await this.postRequest(\n        `${this.apiUrl}/v1/deep-research`,\n        { topic, ...params },\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"start deep research\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * @deprecated Use checkDeepResearchStatus() instead\n   * Checks the status of a deep research operation.\n   * @param id - The ID of the deep research operation.\n   * @returns The current status and results of the research operation.\n   */\n  async __checkDeepResearchStatus(id) {\n    const headers = this.prepareHeaders();\n    try {\n      const response = await this.getRequest(\n        `${this.apiUrl}/v1/deep-research/${id}`,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else if (response.status === 404) {\n        throw new FirecrawlError(\"Deep research job not found\", 404);\n      } else {\n        this.handleError(response, \"check deep research status\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Generates LLMs.txt for a given URL and polls until completion.\n   * @param url - The URL to generate LLMs.txt from.\n   * @param params - Parameters for the LLMs.txt generation operation.\n   * @returns The final generation results.\n   */\n  async generateLLMsText(url, params) {\n    try {\n      const response = await this.asyncGenerateLLMsText(url, params);\n      if (!response.success || \"error\" in response) {\n        return { success: false, error: \"error\" in response ? response.error : \"Unknown error\" };\n      }\n      if (!response.id) {\n        throw new FirecrawlError(`Failed to start LLMs.txt generation. No job ID returned.`, 500);\n      }\n      const jobId = response.id;\n      let generationStatus;\n      while (true) {\n        generationStatus = await this.checkGenerateLLMsTextStatus(jobId);\n        if (\"error\" in generationStatus && !generationStatus.success) {\n          return generationStatus;\n        }\n        if (generationStatus.status === \"completed\") {\n          return generationStatus;\n        }\n        if (generationStatus.status === \"failed\") {\n          throw new FirecrawlError(\n            `LLMs.txt generation job ${generationStatus.status}. Error: ${generationStatus.error}`,\n            500\n          );\n        }\n        if (generationStatus.status !== \"processing\") {\n          break;\n        }\n        await new Promise((resolve) => setTimeout(resolve, 2e3));\n      }\n      return { success: false, error: \"LLMs.txt generation job terminated unexpectedly\" };\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500, error.response?.data?.details);\n    }\n  }\n  /**\n   * Initiates a LLMs.txt generation operation without polling.\n   * @param url - The URL to generate LLMs.txt from.\n   * @param params - Parameters for the LLMs.txt generation operation.\n   * @returns The response containing the generation job ID.\n   */\n  async asyncGenerateLLMsText(url, params) {\n    const headers = this.prepareHeaders();\n    try {\n      const response = await this.postRequest(\n        `${this.apiUrl}/v1/llmstxt`,\n        { url, ...params },\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"start LLMs.txt generation\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Checks the status of a LLMs.txt generation operation.\n   * @param id - The ID of the LLMs.txt generation operation.\n   * @returns The current status and results of the generation operation.\n   */\n  async checkGenerateLLMsTextStatus(id) {\n    const headers = this.prepareHeaders();\n    try {\n      const response = await this.getRequest(\n        `${this.apiUrl}/v1/llmstxt/${id}`,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else if (response.status === 404) {\n        throw new FirecrawlError(\"LLMs.txt generation job not found\", 404);\n      } else {\n        this.handleError(response, \"check LLMs.txt generation status\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n};\nvar CrawlWatcher = class extends typescript_event_target__WEBPACK_IMPORTED_MODULE_1__.TypedEventTarget {\n  ws;\n  data;\n  status;\n  id;\n  constructor(id, app) {\n    super();\n    this.id = id;\n    const wsUrl = app.apiUrl.replace(/^http/, \"ws\");\n    this.ws = new isows__WEBPACK_IMPORTED_MODULE_5__.WebSocket(`${wsUrl}/v1/crawl/${id}`, app.apiKey);\n    this.status = \"scraping\";\n    this.data = [];\n    const messageHandler = (msg) => {\n      if (msg.type === \"done\") {\n        this.status = \"completed\";\n        this.dispatchTypedEvent(\"done\", new CustomEvent(\"done\", {\n          detail: {\n            status: this.status,\n            data: this.data,\n            id: this.id\n          }\n        }));\n      } else if (msg.type === \"error\") {\n        this.status = \"failed\";\n        this.dispatchTypedEvent(\"error\", new CustomEvent(\"error\", {\n          detail: {\n            status: this.status,\n            data: this.data,\n            error: msg.error,\n            id: this.id\n          }\n        }));\n      } else if (msg.type === \"catchup\") {\n        this.status = msg.data.status;\n        this.data.push(...msg.data.data ?? []);\n        for (const doc of this.data) {\n          this.dispatchTypedEvent(\"document\", new CustomEvent(\"document\", {\n            detail: {\n              ...doc,\n              id: this.id\n            }\n          }));\n        }\n      } else if (msg.type === \"document\") {\n        this.dispatchTypedEvent(\"document\", new CustomEvent(\"document\", {\n          detail: {\n            ...msg.data,\n            id: this.id\n          }\n        }));\n      }\n    };\n    this.ws.onmessage = ((ev) => {\n      if (typeof ev.data !== \"string\") {\n        this.ws.close();\n        return;\n      }\n      try {\n        const msg = JSON.parse(ev.data);\n        messageHandler(msg);\n      } catch (error) {\n        console.error(\"Error on message\", error);\n      }\n    }).bind(this);\n    this.ws.onclose = ((ev) => {\n      try {\n        const msg = JSON.parse(ev.reason);\n        messageHandler(msg);\n      } catch (error) {\n        console.error(\"Error on close\", error);\n      }\n    }).bind(this);\n    this.ws.onerror = ((_) => {\n      this.status = \"failed\";\n      this.dispatchTypedEvent(\"error\", new CustomEvent(\"error\", {\n        detail: {\n          status: this.status,\n          data: this.data,\n          error: \"WebSocket error\",\n          id: this.id\n        }\n      }));\n    }).bind(this);\n  }\n  close() {\n    this.ws.close();\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG1lbmRhYmxlL2ZpcmVjcmF3bC1qcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQzBDO0FBQ2hCO0FBQzJCO0FBQ25CO0FBQ3lCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixZQUFZO0FBQzNDO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtRUFBZTtBQUNoQyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1FQUFlO0FBQ2hDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2Q0FBSztBQUNsQztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLG1FQUFtRSxtQkFBbUI7QUFDdEY7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFlBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtRUFB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NENBQVMsSUFBSSxNQUFNLFlBQVksR0FBRztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtFIiwic291cmNlcyI6WyIvVXNlcnMvam9zaHVhaGF5ZG9uL2FpLW1hcmtldGluZy1wcm8vbm9kZV9tb2R1bGVzL0BtZW5kYWJsZS9maXJlY3Jhd2wtanMvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW5kZXgudHNcbmltcG9ydCBheGlvcywgeyBBeGlvc0Vycm9yIH0gZnJvbSBcImF4aW9zXCI7XG5pbXBvcnQgKiBhcyB6dCBmcm9tIFwiem9kXCI7XG5pbXBvcnQgeyB6b2RUb0pzb25TY2hlbWEgfSBmcm9tIFwiem9kLXRvLWpzb24tc2NoZW1hXCI7XG5pbXBvcnQgeyBXZWJTb2NrZXQgfSBmcm9tIFwiaXNvd3NcIjtcbmltcG9ydCB7IFR5cGVkRXZlbnRUYXJnZXQgfSBmcm9tIFwidHlwZXNjcmlwdC1ldmVudC10YXJnZXRcIjtcbnZhciBGaXJlY3Jhd2xFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBzdGF0dXNDb2RlO1xuICBkZXRhaWxzO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXNDb2RlLCBkZXRhaWxzKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICB9XG59O1xudmFyIEZpcmVjcmF3bEFwcCA9IGNsYXNzIHtcbiAgYXBpS2V5O1xuICBhcGlVcmw7XG4gIGlzQ2xvdWRTZXJ2aWNlKHVybCkge1xuICAgIHJldHVybiB1cmwuaW5jbHVkZXMoXCJhcGkuZmlyZWNyYXdsLmRldlwiKTtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIEZpcmVjcmF3bEFwcCBjbGFzcy5cbiAgICogQHBhcmFtIGNvbmZpZyAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIEZpcmVjcmF3bEFwcCBpbnN0YW5jZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgYXBpS2V5ID0gbnVsbCwgYXBpVXJsID0gbnVsbCB9KSB7XG4gICAgY29uc3QgYmFzZVVybCA9IGFwaVVybCB8fCBcImh0dHBzOi8vYXBpLmZpcmVjcmF3bC5kZXZcIjtcbiAgICBpZiAodGhpcy5pc0Nsb3VkU2VydmljZShiYXNlVXJsKSAmJiB0eXBlb2YgYXBpS2V5ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoXCJObyBBUEkga2V5IHByb3ZpZGVkXCIsIDQwMSk7XG4gICAgfVxuICAgIHRoaXMuYXBpS2V5ID0gYXBpS2V5IHx8IFwiXCI7XG4gICAgdGhpcy5hcGlVcmwgPSBiYXNlVXJsO1xuICB9XG4gIC8qKlxuICAgKiBTY3JhcGVzIGEgVVJMIHVzaW5nIHRoZSBGaXJlY3Jhd2wgQVBJLlxuICAgKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0byBzY3JhcGUuXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBBZGRpdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoZSBzY3JhcGUgcmVxdWVzdC5cbiAgICogQHJldHVybnMgVGhlIHJlc3BvbnNlIGZyb20gdGhlIHNjcmFwZSBvcGVyYXRpb24uXG4gICAqL1xuICBhc3luYyBzY3JhcGVVcmwodXJsLCBwYXJhbXMpIHtcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dGhpcy5hcGlLZXl9YFxuICAgIH07XG4gICAgbGV0IGpzb25EYXRhID0geyB1cmwsIC4uLnBhcmFtcyB9O1xuICAgIGlmIChqc29uRGF0YT8uZXh0cmFjdD8uc2NoZW1hKSB7XG4gICAgICBsZXQgc2NoZW1hID0ganNvbkRhdGEuZXh0cmFjdC5zY2hlbWE7XG4gICAgICB0cnkge1xuICAgICAgICBzY2hlbWEgPSB6b2RUb0pzb25TY2hlbWEoc2NoZW1hKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB9XG4gICAgICBqc29uRGF0YSA9IHtcbiAgICAgICAgLi4uanNvbkRhdGEsXG4gICAgICAgIGV4dHJhY3Q6IHtcbiAgICAgICAgICAuLi5qc29uRGF0YS5leHRyYWN0LFxuICAgICAgICAgIHNjaGVtYVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoanNvbkRhdGE/Lmpzb25PcHRpb25zPy5zY2hlbWEpIHtcbiAgICAgIGxldCBzY2hlbWEgPSBqc29uRGF0YS5qc29uT3B0aW9ucy5zY2hlbWE7XG4gICAgICB0cnkge1xuICAgICAgICBzY2hlbWEgPSB6b2RUb0pzb25TY2hlbWEoc2NoZW1hKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB9XG4gICAgICBqc29uRGF0YSA9IHtcbiAgICAgICAgLi4uanNvbkRhdGEsXG4gICAgICAgIGpzb25PcHRpb25zOiB7XG4gICAgICAgICAgLi4uanNvbkRhdGEuanNvbk9wdGlvbnMsXG4gICAgICAgICAgc2NoZW1hXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLnBvc3QoXG4gICAgICAgIHRoaXMuYXBpVXJsICsgYC92MS9zY3JhcGVgLFxuICAgICAgICBqc29uRGF0YSxcbiAgICAgICAgeyBoZWFkZXJzLCB0aW1lb3V0OiBwYXJhbXM/LnRpbWVvdXQgIT09IHZvaWQgMCA/IHBhcmFtcy50aW1lb3V0ICsgNWUzIDogdm9pZCAwIH1cbiAgICAgICk7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgaWYgKHJlc3BvbnNlRGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICB3YXJuaW5nOiByZXNwb25zZURhdGEud2FybmluZyxcbiAgICAgICAgICAgIGVycm9yOiByZXNwb25zZURhdGEuZXJyb3IsXG4gICAgICAgICAgICAuLi5yZXNwb25zZURhdGEuZGF0YVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGBGYWlsZWQgdG8gc2NyYXBlIFVSTC4gRXJyb3I6ICR7cmVzcG9uc2VEYXRhLmVycm9yfWAsIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IocmVzcG9uc2UsIFwic2NyYXBlIFVSTFwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5oYW5kbGVFcnJvcihlcnJvci5yZXNwb25zZSwgXCJzY3JhcGUgVVJMXCIpO1xuICAgIH1cbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiSW50ZXJuYWwgc2VydmVyIGVycm9yLlwiIH07XG4gIH1cbiAgLyoqXG4gICAqIFNlYXJjaGVzIHVzaW5nIHRoZSBGaXJlY3Jhd2wgQVBJIGFuZCBvcHRpb25hbGx5IHNjcmFwZXMgdGhlIHJlc3VsdHMuXG4gICAqIEBwYXJhbSBxdWVyeSAtIFRoZSBzZWFyY2ggcXVlcnkgc3RyaW5nLlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gT3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgdGhlIHNlYXJjaCByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgc2VhcmNoIG9wZXJhdGlvbi5cbiAgICovXG4gIGFzeW5jIHNlYXJjaChxdWVyeSwgcGFyYW1zKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMuYXBpS2V5fWBcbiAgICB9O1xuICAgIGxldCBqc29uRGF0YSA9IHtcbiAgICAgIHF1ZXJ5LFxuICAgICAgbGltaXQ6IHBhcmFtcz8ubGltaXQgPz8gNSxcbiAgICAgIHRiczogcGFyYW1zPy50YnMsXG4gICAgICBmaWx0ZXI6IHBhcmFtcz8uZmlsdGVyLFxuICAgICAgbGFuZzogcGFyYW1zPy5sYW5nID8/IFwiZW5cIixcbiAgICAgIGNvdW50cnk6IHBhcmFtcz8uY291bnRyeSA/PyBcInVzXCIsXG4gICAgICBsb2NhdGlvbjogcGFyYW1zPy5sb2NhdGlvbixcbiAgICAgIG9yaWdpbjogcGFyYW1zPy5vcmlnaW4gPz8gXCJhcGlcIixcbiAgICAgIHRpbWVvdXQ6IHBhcmFtcz8udGltZW91dCA/PyA2ZTQsXG4gICAgICBzY3JhcGVPcHRpb25zOiBwYXJhbXM/LnNjcmFwZU9wdGlvbnMgPz8geyBmb3JtYXRzOiBbXSB9XG4gICAgfTtcbiAgICBpZiAoanNvbkRhdGE/LnNjcmFwZU9wdGlvbnM/LmV4dHJhY3Q/LnNjaGVtYSkge1xuICAgICAgbGV0IHNjaGVtYSA9IGpzb25EYXRhLnNjcmFwZU9wdGlvbnMuZXh0cmFjdC5zY2hlbWE7XG4gICAgICB0cnkge1xuICAgICAgICBzY2hlbWEgPSB6b2RUb0pzb25TY2hlbWEoc2NoZW1hKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB9XG4gICAgICBqc29uRGF0YSA9IHtcbiAgICAgICAgLi4uanNvbkRhdGEsXG4gICAgICAgIHNjcmFwZU9wdGlvbnM6IHtcbiAgICAgICAgICAuLi5qc29uRGF0YS5zY3JhcGVPcHRpb25zLFxuICAgICAgICAgIGV4dHJhY3Q6IHtcbiAgICAgICAgICAgIC4uLmpzb25EYXRhLnNjcmFwZU9wdGlvbnMuZXh0cmFjdCxcbiAgICAgICAgICAgIHNjaGVtYVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wb3N0UmVxdWVzdChcbiAgICAgICAgdGhpcy5hcGlVcmwgKyBgL3YxL3NlYXJjaGAsXG4gICAgICAgIGpzb25EYXRhLFxuICAgICAgICBoZWFkZXJzXG4gICAgICApO1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIGlmIChyZXNwb25zZURhdGEuc3VjY2Vzcykge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLmRhdGEsXG4gICAgICAgICAgICB3YXJuaW5nOiByZXNwb25zZURhdGEud2FybmluZ1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGBGYWlsZWQgdG8gc2VhcmNoLiBFcnJvcjogJHtyZXNwb25zZURhdGEuZXJyb3J9YCwgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihyZXNwb25zZSwgXCJzZWFyY2hcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5yZXNwb25zZT8uZGF0YT8uZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGBSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICR7ZXJyb3IucmVzcG9uc2Uuc3RhdHVzfS4gRXJyb3I6ICR7ZXJyb3IucmVzcG9uc2UuZGF0YS5lcnJvcn0gJHtlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbHMgPyBgIC0gJHtKU09OLnN0cmluZ2lmeShlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbHMpfWAgOiBcIlwifWAsIGVycm9yLnJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoZXJyb3IubWVzc2FnZSwgNTAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIkludGVybmFsIHNlcnZlciBlcnJvci5cIiwgZGF0YTogW10gfTtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhdGVzIGEgY3Jhd2wgam9iIGZvciBhIFVSTCB1c2luZyB0aGUgRmlyZWNyYXdsIEFQSS5cbiAgICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdG8gY3Jhd2wuXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBBZGRpdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoZSBjcmF3bCByZXF1ZXN0LlxuICAgKiBAcGFyYW0gcG9sbEludGVydmFsIC0gVGltZSBpbiBzZWNvbmRzIGZvciBqb2Igc3RhdHVzIGNoZWNrcy5cbiAgICogQHBhcmFtIGlkZW1wb3RlbmN5S2V5IC0gT3B0aW9uYWwgaWRlbXBvdGVuY3kga2V5IGZvciB0aGUgcmVxdWVzdC5cbiAgICogQHJldHVybnMgVGhlIHJlc3BvbnNlIGZyb20gdGhlIGNyYXdsIG9wZXJhdGlvbi5cbiAgICovXG4gIGFzeW5jIGNyYXdsVXJsKHVybCwgcGFyYW1zLCBwb2xsSW50ZXJ2YWwgPSAyLCBpZGVtcG90ZW5jeUtleSkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnByZXBhcmVIZWFkZXJzKGlkZW1wb3RlbmN5S2V5KTtcbiAgICBsZXQganNvbkRhdGEgPSB7IHVybCwgLi4ucGFyYW1zIH07XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wb3N0UmVxdWVzdChcbiAgICAgICAgdGhpcy5hcGlVcmwgKyBgL3YxL2NyYXdsYCxcbiAgICAgICAganNvbkRhdGEsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgICk7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgY29uc3QgaWQgPSByZXNwb25zZS5kYXRhLmlkO1xuICAgICAgICByZXR1cm4gdGhpcy5tb25pdG9ySm9iU3RhdHVzKGlkLCBoZWFkZXJzLCBwb2xsSW50ZXJ2YWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihyZXNwb25zZSwgXCJzdGFydCBjcmF3bCBqb2JcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5yZXNwb25zZT8uZGF0YT8uZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGBSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICR7ZXJyb3IucmVzcG9uc2Uuc3RhdHVzfS4gRXJyb3I6ICR7ZXJyb3IucmVzcG9uc2UuZGF0YS5lcnJvcn0gJHtlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbHMgPyBgIC0gJHtKU09OLnN0cmluZ2lmeShlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbHMpfWAgOiBcIlwifWAsIGVycm9yLnJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoZXJyb3IubWVzc2FnZSwgNTAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIkludGVybmFsIHNlcnZlciBlcnJvci5cIiB9O1xuICB9XG4gIGFzeW5jIGFzeW5jQ3Jhd2xVcmwodXJsLCBwYXJhbXMsIGlkZW1wb3RlbmN5S2V5KSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHRoaXMucHJlcGFyZUhlYWRlcnMoaWRlbXBvdGVuY3lLZXkpO1xuICAgIGxldCBqc29uRGF0YSA9IHsgdXJsLCAuLi5wYXJhbXMgfTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnBvc3RSZXF1ZXN0KFxuICAgICAgICB0aGlzLmFwaVVybCArIGAvdjEvY3Jhd2xgLFxuICAgICAgICBqc29uRGF0YSxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgKTtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IocmVzcG9uc2UsIFwic3RhcnQgY3Jhd2wgam9iXCIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IucmVzcG9uc2U/LmRhdGE/LmVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihgUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAke2Vycm9yLnJlc3BvbnNlLnN0YXR1c30uIEVycm9yOiAke2Vycm9yLnJlc3BvbnNlLmRhdGEuZXJyb3J9ICR7ZXJyb3IucmVzcG9uc2UuZGF0YS5kZXRhaWxzID8gYCAtICR7SlNPTi5zdHJpbmdpZnkoZXJyb3IucmVzcG9uc2UuZGF0YS5kZXRhaWxzKX1gIDogXCJcIn1gLCBlcnJvci5yZXNwb25zZS5zdGF0dXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGVycm9yLm1lc3NhZ2UsIDUwMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJJbnRlcm5hbCBzZXJ2ZXIgZXJyb3IuXCIgfTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIHRoZSBzdGF0dXMgb2YgYSBjcmF3bCBqb2IgdXNpbmcgdGhlIEZpcmVjcmF3bCBBUEkuXG4gICAqIEBwYXJhbSBpZCAtIFRoZSBJRCBvZiB0aGUgY3Jhd2wgb3BlcmF0aW9uLlxuICAgKiBAcGFyYW0gZ2V0QWxsRGF0YSAtIFBhZ2luYXRlIHRocm91Z2ggYWxsIHRoZSBwYWdlcyBvZiBkb2N1bWVudHMsIHJldHVybmluZyB0aGUgZnVsbCBsaXN0IG9mIGFsbCBkb2N1bWVudHMuIChkZWZhdWx0OiBgZmFsc2VgKVxuICAgKiBAcGFyYW0gbmV4dFVSTCAtIFRoZSBgbmV4dGAgVVJMIGZyb20gdGhlIHByZXZpb3VzIGNyYXdsIHN0YXR1cy4gT25seSByZXF1aXJlZCBpZiB5b3UncmUgbm90IG1hbnVhbGx5IGluY3JlYXNpbmcgYHNraXBgLiBPbmx5IHVzZWQgd2hlbiBgZ2V0QWxsRGF0YSA9IGZhbHNlYC5cbiAgICogQHBhcmFtIHNraXAgLSBIb3cgbWFueSBlbnRyaWVzIHRvIHNraXAgdG8gcGFnaW5hdGUuIE9ubHkgcmVxdWlyZWQgaWYgeW91J3JlIG5vdCBwcm92aWRpbmcgYG5leHRVUkxgLiBPbmx5IHVzZWQgd2hlbiBgZ2V0QWxsRGF0YSA9IGZhbHNlYC5cbiAgICogQHBhcmFtIGxpbWl0IC0gSG93IG1hbnkgZW50cmllcyB0byByZXR1cm4uIE9ubHkgdXNlZCB3aGVuIGBnZXRBbGxEYXRhID0gZmFsc2VgLlxuICAgKiBAcmV0dXJucyBUaGUgcmVzcG9uc2UgY29udGFpbmluZyB0aGUgam9iIHN0YXR1cy5cbiAgICovXG4gIGFzeW5jIGNoZWNrQ3Jhd2xTdGF0dXMoaWQsIGdldEFsbERhdGEgPSBmYWxzZSwgbmV4dFVSTCwgc2tpcCwgbGltaXQpIHtcbiAgICBpZiAoIWlkKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoXCJObyBjcmF3bCBJRCBwcm92aWRlZFwiLCA0MDApO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5wcmVwYXJlSGVhZGVycygpO1xuICAgIGNvbnN0IHRhcmdldFVSTCA9IG5ldyBVUkwobmV4dFVSTCA/PyBgJHt0aGlzLmFwaVVybH0vdjEvY3Jhd2wvJHtpZH1gKTtcbiAgICBpZiAoc2tpcCAhPT0gdm9pZCAwKSB7XG4gICAgICB0YXJnZXRVUkwuc2VhcmNoUGFyYW1zLnNldChcInNraXBcIiwgc2tpcC50b1N0cmluZygpKTtcbiAgICB9XG4gICAgaWYgKGxpbWl0ICE9PSB2b2lkIDApIHtcbiAgICAgIHRhcmdldFVSTC5zZWFyY2hQYXJhbXMuc2V0KFwibGltaXRcIiwgbGltaXQudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0UmVxdWVzdChcbiAgICAgICAgdGFyZ2V0VVJMLmhyZWYsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgICk7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgbGV0IGFsbERhdGEgPSByZXNwb25zZS5kYXRhLmRhdGE7XG4gICAgICAgIGlmIChnZXRBbGxEYXRhICYmIHJlc3BvbnNlLmRhdGEuc3RhdHVzID09PSBcImNvbXBsZXRlZFwiKSB7XG4gICAgICAgICAgbGV0IHN0YXR1c0RhdGEgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICAgIGlmIChcImRhdGFcIiBpbiBzdGF0dXNEYXRhKSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHN0YXR1c0RhdGEuZGF0YTtcbiAgICAgICAgICAgIHdoaWxlICh0eXBlb2Ygc3RhdHVzRGF0YSA9PT0gXCJvYmplY3RcIiAmJiBcIm5leHRcIiBpbiBzdGF0dXNEYXRhKSB7XG4gICAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0YXR1c0RhdGEgPSAoYXdhaXQgdGhpcy5nZXRSZXF1ZXN0KHN0YXR1c0RhdGEubmV4dCwgaGVhZGVycykpLmRhdGE7XG4gICAgICAgICAgICAgIGRhdGEgPSBkYXRhLmNvbmNhdChzdGF0dXNEYXRhLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWxsRGF0YSA9IGRhdGE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwID0ge1xuICAgICAgICAgIHN1Y2Nlc3M6IHJlc3BvbnNlLmRhdGEuc3VjY2VzcyxcbiAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLmRhdGEuc3RhdHVzLFxuICAgICAgICAgIHRvdGFsOiByZXNwb25zZS5kYXRhLnRvdGFsLFxuICAgICAgICAgIGNvbXBsZXRlZDogcmVzcG9uc2UuZGF0YS5jb21wbGV0ZWQsXG4gICAgICAgICAgY3JlZGl0c1VzZWQ6IHJlc3BvbnNlLmRhdGEuY3JlZGl0c1VzZWQsXG4gICAgICAgICAgbmV4dDogZ2V0QWxsRGF0YSA/IHZvaWQgMCA6IHJlc3BvbnNlLmRhdGEubmV4dCxcbiAgICAgICAgICBleHBpcmVzQXQ6IG5ldyBEYXRlKHJlc3BvbnNlLmRhdGEuZXhwaXJlc0F0KSxcbiAgICAgICAgICBkYXRhOiBhbGxEYXRhXG4gICAgICAgIH07XG4gICAgICAgIGlmICghcmVzcG9uc2UuZGF0YS5zdWNjZXNzICYmIHJlc3BvbnNlLmRhdGEuZXJyb3IpIHtcbiAgICAgICAgICByZXNwID0ge1xuICAgICAgICAgICAgLi4ucmVzcCxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IHJlc3BvbnNlLmRhdGEuZXJyb3JcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNwb25zZS5kYXRhLm5leHQpIHtcbiAgICAgICAgICByZXNwLm5leHQgPSByZXNwb25zZS5kYXRhLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZUVycm9yKHJlc3BvbnNlLCBcImNoZWNrIGNyYXdsIHN0YXR1c1wiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGVycm9yLm1lc3NhZ2UsIDUwMCk7XG4gICAgfVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJJbnRlcm5hbCBzZXJ2ZXIgZXJyb3IuXCIgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCBjcmF3bCBlcnJvcnMuXG4gICAqIEBwYXJhbSBpZCAtIFRoZSBJRCBvZiB0aGUgY3Jhd2wgb3BlcmF0aW9uLlxuICAgKiBAcmV0dXJucyBJbmZvcm1hdGlvbiBhYm91dCBjcmF3bCBlcnJvcnMuXG4gICAqL1xuICBhc3luYyBjaGVja0NyYXdsRXJyb3JzKGlkKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHRoaXMucHJlcGFyZUhlYWRlcnMoKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmRlbGV0ZVJlcXVlc3QoXG4gICAgICAgIGAke3RoaXMuYXBpVXJsfS92MS9jcmF3bC8ke2lkfS9lcnJvcnNgLFxuICAgICAgICBoZWFkZXJzXG4gICAgICApO1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihyZXNwb25zZSwgXCJjaGVjayBjcmF3bCBlcnJvcnNcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDApO1xuICAgIH1cbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiSW50ZXJuYWwgc2VydmVyIGVycm9yLlwiIH07XG4gIH1cbiAgLyoqXG4gICAqIENhbmNlbHMgYSBjcmF3bCBqb2IgdXNpbmcgdGhlIEZpcmVjcmF3bCBBUEkuXG4gICAqIEBwYXJhbSBpZCAtIFRoZSBJRCBvZiB0aGUgY3Jhd2wgb3BlcmF0aW9uLlxuICAgKiBAcmV0dXJucyBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgY2FuY2VsIGNyYXdsIG9wZXJhdGlvbi5cbiAgICovXG4gIGFzeW5jIGNhbmNlbENyYXdsKGlkKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHRoaXMucHJlcGFyZUhlYWRlcnMoKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmRlbGV0ZVJlcXVlc3QoXG4gICAgICAgIGAke3RoaXMuYXBpVXJsfS92MS9jcmF3bC8ke2lkfWAsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgICk7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZUVycm9yKHJlc3BvbnNlLCBcImNhbmNlbCBjcmF3bCBqb2JcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDApO1xuICAgIH1cbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiSW50ZXJuYWwgc2VydmVyIGVycm9yLlwiIH07XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYXRlcyBhIGNyYXdsIGpvYiBhbmQgcmV0dXJucyBhIENyYXdsV2F0Y2hlciB0byBtb25pdG9yIHRoZSBqb2IgdmlhIFdlYlNvY2tldC5cbiAgICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdG8gY3Jhd2wuXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBBZGRpdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoZSBjcmF3bCByZXF1ZXN0LlxuICAgKiBAcGFyYW0gaWRlbXBvdGVuY3lLZXkgLSBPcHRpb25hbCBpZGVtcG90ZW5jeSBrZXkgZm9yIHRoZSByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBBIENyYXdsV2F0Y2hlciBpbnN0YW5jZSB0byBtb25pdG9yIHRoZSBjcmF3bCBqb2IuXG4gICAqL1xuICBhc3luYyBjcmF3bFVybEFuZFdhdGNoKHVybCwgcGFyYW1zLCBpZGVtcG90ZW5jeUtleSkge1xuICAgIGNvbnN0IGNyYXdsID0gYXdhaXQgdGhpcy5hc3luY0NyYXdsVXJsKHVybCwgcGFyYW1zLCBpZGVtcG90ZW5jeUtleSk7XG4gICAgaWYgKGNyYXdsLnN1Y2Nlc3MgJiYgY3Jhd2wuaWQpIHtcbiAgICAgIGNvbnN0IGlkID0gY3Jhd2wuaWQ7XG4gICAgICByZXR1cm4gbmV3IENyYXdsV2F0Y2hlcihpZCwgdGhpcyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihcIkNyYXdsIGpvYiBmYWlsZWQgdG8gc3RhcnRcIiwgNDAwKTtcbiAgfVxuICAvKipcbiAgICogTWFwcyBhIFVSTCB1c2luZyB0aGUgRmlyZWNyYXdsIEFQSS5cbiAgICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdG8gbWFwLlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gQWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZvciB0aGUgbWFwIHJlcXVlc3QuXG4gICAqIEByZXR1cm5zIFRoZSByZXNwb25zZSBmcm9tIHRoZSBtYXAgb3BlcmF0aW9uLlxuICAgKi9cbiAgYXN5bmMgbWFwVXJsKHVybCwgcGFyYW1zKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHRoaXMucHJlcGFyZUhlYWRlcnMoKTtcbiAgICBsZXQganNvbkRhdGEgPSB7IHVybCwgLi4ucGFyYW1zIH07XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wb3N0UmVxdWVzdChcbiAgICAgICAgdGhpcy5hcGlVcmwgKyBgL3YxL21hcGAsXG4gICAgICAgIGpzb25EYXRhLFxuICAgICAgICBoZWFkZXJzXG4gICAgICApO1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihyZXNwb25zZSwgXCJtYXBcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDApO1xuICAgIH1cbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiSW50ZXJuYWwgc2VydmVyIGVycm9yLlwiIH07XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYXRlcyBhIGJhdGNoIHNjcmFwZSBqb2IgZm9yIG11bHRpcGxlIFVSTHMgdXNpbmcgdGhlIEZpcmVjcmF3bCBBUEkuXG4gICAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMcyB0byBzY3JhcGUuXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBBZGRpdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoZSBzY3JhcGUgcmVxdWVzdC5cbiAgICogQHBhcmFtIHBvbGxJbnRlcnZhbCAtIFRpbWUgaW4gc2Vjb25kcyBmb3Igam9iIHN0YXR1cyBjaGVja3MuXG4gICAqIEBwYXJhbSBpZGVtcG90ZW5jeUtleSAtIE9wdGlvbmFsIGlkZW1wb3RlbmN5IGtleSBmb3IgdGhlIHJlcXVlc3QuXG4gICAqIEBwYXJhbSB3ZWJob29rIC0gT3B0aW9uYWwgd2ViaG9vayBmb3IgdGhlIGJhdGNoIHNjcmFwZS5cbiAgICogQHBhcmFtIGlnbm9yZUludmFsaWRVUkxzIC0gT3B0aW9uYWwgZmxhZyB0byBpZ25vcmUgaW52YWxpZCBVUkxzLlxuICAgKiBAcmV0dXJucyBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgY3Jhd2wgb3BlcmF0aW9uLlxuICAgKi9cbiAgYXN5bmMgYmF0Y2hTY3JhcGVVcmxzKHVybHMsIHBhcmFtcywgcG9sbEludGVydmFsID0gMiwgaWRlbXBvdGVuY3lLZXksIHdlYmhvb2ssIGlnbm9yZUludmFsaWRVUkxzKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHRoaXMucHJlcGFyZUhlYWRlcnMoaWRlbXBvdGVuY3lLZXkpO1xuICAgIGxldCBqc29uRGF0YSA9IHsgdXJscywgd2ViaG9vaywgaWdub3JlSW52YWxpZFVSTHMsIC4uLnBhcmFtcyB9O1xuICAgIGlmIChqc29uRGF0YT8uZXh0cmFjdD8uc2NoZW1hKSB7XG4gICAgICBsZXQgc2NoZW1hID0ganNvbkRhdGEuZXh0cmFjdC5zY2hlbWE7XG4gICAgICB0cnkge1xuICAgICAgICBzY2hlbWEgPSB6b2RUb0pzb25TY2hlbWEoc2NoZW1hKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB9XG4gICAgICBqc29uRGF0YSA9IHtcbiAgICAgICAgLi4uanNvbkRhdGEsXG4gICAgICAgIGV4dHJhY3Q6IHtcbiAgICAgICAgICAuLi5qc29uRGF0YS5leHRyYWN0LFxuICAgICAgICAgIHNjaGVtYVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoanNvbkRhdGE/Lmpzb25PcHRpb25zPy5zY2hlbWEpIHtcbiAgICAgIGxldCBzY2hlbWEgPSBqc29uRGF0YS5qc29uT3B0aW9ucy5zY2hlbWE7XG4gICAgICB0cnkge1xuICAgICAgICBzY2hlbWEgPSB6b2RUb0pzb25TY2hlbWEoc2NoZW1hKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB9XG4gICAgICBqc29uRGF0YSA9IHtcbiAgICAgICAgLi4uanNvbkRhdGEsXG4gICAgICAgIGpzb25PcHRpb25zOiB7XG4gICAgICAgICAgLi4uanNvbkRhdGEuanNvbk9wdGlvbnMsXG4gICAgICAgICAgc2NoZW1hXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucG9zdFJlcXVlc3QoXG4gICAgICAgIHRoaXMuYXBpVXJsICsgYC92MS9iYXRjaC9zY3JhcGVgLFxuICAgICAgICBqc29uRGF0YSxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgKTtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICBjb25zdCBpZCA9IHJlc3BvbnNlLmRhdGEuaWQ7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbml0b3JKb2JTdGF0dXMoaWQsIGhlYWRlcnMsIHBvbGxJbnRlcnZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZUVycm9yKHJlc3BvbnNlLCBcInN0YXJ0IGJhdGNoIHNjcmFwZSBqb2JcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5yZXNwb25zZT8uZGF0YT8uZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGBSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICR7ZXJyb3IucmVzcG9uc2Uuc3RhdHVzfS4gRXJyb3I6ICR7ZXJyb3IucmVzcG9uc2UuZGF0YS5lcnJvcn0gJHtlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbHMgPyBgIC0gJHtKU09OLnN0cmluZ2lmeShlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbHMpfWAgOiBcIlwifWAsIGVycm9yLnJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoZXJyb3IubWVzc2FnZSwgNTAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIkludGVybmFsIHNlcnZlciBlcnJvci5cIiB9O1xuICB9XG4gIGFzeW5jIGFzeW5jQmF0Y2hTY3JhcGVVcmxzKHVybHMsIHBhcmFtcywgaWRlbXBvdGVuY3lLZXksIHdlYmhvb2ssIGlnbm9yZUludmFsaWRVUkxzKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHRoaXMucHJlcGFyZUhlYWRlcnMoaWRlbXBvdGVuY3lLZXkpO1xuICAgIGxldCBqc29uRGF0YSA9IHsgdXJscywgd2ViaG9vaywgaWdub3JlSW52YWxpZFVSTHMsIC4uLnBhcmFtcyA/PyB7fSB9O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucG9zdFJlcXVlc3QoXG4gICAgICAgIHRoaXMuYXBpVXJsICsgYC92MS9iYXRjaC9zY3JhcGVgLFxuICAgICAgICBqc29uRGF0YSxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgKTtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IocmVzcG9uc2UsIFwic3RhcnQgYmF0Y2ggc2NyYXBlIGpvYlwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yLnJlc3BvbnNlPy5kYXRhPy5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoYFJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJHtlcnJvci5yZXNwb25zZS5zdGF0dXN9LiBFcnJvcjogJHtlcnJvci5yZXNwb25zZS5kYXRhLmVycm9yfSAke2Vycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlscyA/IGAgLSAke0pTT04uc3RyaW5naWZ5KGVycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlscyl9YCA6IFwiXCJ9YCwgZXJyb3IucmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiSW50ZXJuYWwgc2VydmVyIGVycm9yLlwiIH07XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYXRlcyBhIGJhdGNoIHNjcmFwZSBqb2IgYW5kIHJldHVybnMgYSBDcmF3bFdhdGNoZXIgdG8gbW9uaXRvciB0aGUgam9iIHZpYSBXZWJTb2NrZXQuXG4gICAqIEBwYXJhbSB1cmxzIC0gVGhlIFVSTCB0byBzY3JhcGUuXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBBZGRpdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoZSBzY3JhcGUgcmVxdWVzdC5cbiAgICogQHBhcmFtIGlkZW1wb3RlbmN5S2V5IC0gT3B0aW9uYWwgaWRlbXBvdGVuY3kga2V5IGZvciB0aGUgcmVxdWVzdC5cbiAgICogQHJldHVybnMgQSBDcmF3bFdhdGNoZXIgaW5zdGFuY2UgdG8gbW9uaXRvciB0aGUgY3Jhd2wgam9iLlxuICAgKi9cbiAgYXN5bmMgYmF0Y2hTY3JhcGVVcmxzQW5kV2F0Y2godXJscywgcGFyYW1zLCBpZGVtcG90ZW5jeUtleSwgd2ViaG9vaywgaWdub3JlSW52YWxpZFVSTHMpIHtcbiAgICBjb25zdCBjcmF3bCA9IGF3YWl0IHRoaXMuYXN5bmNCYXRjaFNjcmFwZVVybHModXJscywgcGFyYW1zLCBpZGVtcG90ZW5jeUtleSwgd2ViaG9vaywgaWdub3JlSW52YWxpZFVSTHMpO1xuICAgIGlmIChjcmF3bC5zdWNjZXNzICYmIGNyYXdsLmlkKSB7XG4gICAgICBjb25zdCBpZCA9IGNyYXdsLmlkO1xuICAgICAgcmV0dXJuIG5ldyBDcmF3bFdhdGNoZXIoaWQsIHRoaXMpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoXCJCYXRjaCBzY3JhcGUgam9iIGZhaWxlZCB0byBzdGFydFwiLCA0MDApO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgdGhlIHN0YXR1cyBvZiBhIGJhdGNoIHNjcmFwZSBqb2IgdXNpbmcgdGhlIEZpcmVjcmF3bCBBUEkuXG4gICAqIEBwYXJhbSBpZCAtIFRoZSBJRCBvZiB0aGUgYmF0Y2ggc2NyYXBlIG9wZXJhdGlvbi5cbiAgICogQHBhcmFtIGdldEFsbERhdGEgLSBQYWdpbmF0ZSB0aHJvdWdoIGFsbCB0aGUgcGFnZXMgb2YgZG9jdW1lbnRzLCByZXR1cm5pbmcgdGhlIGZ1bGwgbGlzdCBvZiBhbGwgZG9jdW1lbnRzLiAoZGVmYXVsdDogYGZhbHNlYClcbiAgICogQHBhcmFtIG5leHRVUkwgLSBUaGUgYG5leHRgIFVSTCBmcm9tIHRoZSBwcmV2aW91cyBiYXRjaCBzY3JhcGUgc3RhdHVzLiBPbmx5IHJlcXVpcmVkIGlmIHlvdSdyZSBub3QgbWFudWFsbHkgaW5jcmVhc2luZyBgc2tpcGAuIE9ubHkgdXNlZCB3aGVuIGBnZXRBbGxEYXRhID0gZmFsc2VgLlxuICAgKiBAcGFyYW0gc2tpcCAtIEhvdyBtYW55IGVudHJpZXMgdG8gc2tpcCB0byBwYWdpbmF0ZS4gT25seSB1c2VkIHdoZW4gYGdldEFsbERhdGEgPSBmYWxzZWAuXG4gICAqIEBwYXJhbSBsaW1pdCAtIEhvdyBtYW55IGVudHJpZXMgdG8gcmV0dXJuLiBPbmx5IHVzZWQgd2hlbiBgZ2V0QWxsRGF0YSA9IGZhbHNlYC5cbiAgICogQHJldHVybnMgVGhlIHJlc3BvbnNlIGNvbnRhaW5pbmcgdGhlIGpvYiBzdGF0dXMuXG4gICAqL1xuICBhc3luYyBjaGVja0JhdGNoU2NyYXBlU3RhdHVzKGlkLCBnZXRBbGxEYXRhID0gZmFsc2UsIG5leHRVUkwsIHNraXAsIGxpbWl0KSB7XG4gICAgaWYgKCFpZCkge1xuICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKFwiTm8gYmF0Y2ggc2NyYXBlIElEIHByb3ZpZGVkXCIsIDQwMCk7XG4gICAgfVxuICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnByZXBhcmVIZWFkZXJzKCk7XG4gICAgY29uc3QgdGFyZ2V0VVJMID0gbmV3IFVSTChuZXh0VVJMID8/IGAke3RoaXMuYXBpVXJsfS92MS9iYXRjaC9zY3JhcGUvJHtpZH1gKTtcbiAgICBpZiAoc2tpcCAhPT0gdm9pZCAwKSB7XG4gICAgICB0YXJnZXRVUkwuc2VhcmNoUGFyYW1zLnNldChcInNraXBcIiwgc2tpcC50b1N0cmluZygpKTtcbiAgICB9XG4gICAgaWYgKGxpbWl0ICE9PSB2b2lkIDApIHtcbiAgICAgIHRhcmdldFVSTC5zZWFyY2hQYXJhbXMuc2V0KFwibGltaXRcIiwgbGltaXQudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0UmVxdWVzdChcbiAgICAgICAgdGFyZ2V0VVJMLmhyZWYsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgICk7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgbGV0IGFsbERhdGEgPSByZXNwb25zZS5kYXRhLmRhdGE7XG4gICAgICAgIGlmIChnZXRBbGxEYXRhICYmIHJlc3BvbnNlLmRhdGEuc3RhdHVzID09PSBcImNvbXBsZXRlZFwiKSB7XG4gICAgICAgICAgbGV0IHN0YXR1c0RhdGEgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICAgIGlmIChcImRhdGFcIiBpbiBzdGF0dXNEYXRhKSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHN0YXR1c0RhdGEuZGF0YTtcbiAgICAgICAgICAgIHdoaWxlICh0eXBlb2Ygc3RhdHVzRGF0YSA9PT0gXCJvYmplY3RcIiAmJiBcIm5leHRcIiBpbiBzdGF0dXNEYXRhKSB7XG4gICAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0YXR1c0RhdGEgPSAoYXdhaXQgdGhpcy5nZXRSZXF1ZXN0KHN0YXR1c0RhdGEubmV4dCwgaGVhZGVycykpLmRhdGE7XG4gICAgICAgICAgICAgIGRhdGEgPSBkYXRhLmNvbmNhdChzdGF0dXNEYXRhLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWxsRGF0YSA9IGRhdGE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwID0ge1xuICAgICAgICAgIHN1Y2Nlc3M6IHJlc3BvbnNlLmRhdGEuc3VjY2VzcyxcbiAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLmRhdGEuc3RhdHVzLFxuICAgICAgICAgIHRvdGFsOiByZXNwb25zZS5kYXRhLnRvdGFsLFxuICAgICAgICAgIGNvbXBsZXRlZDogcmVzcG9uc2UuZGF0YS5jb21wbGV0ZWQsXG4gICAgICAgICAgY3JlZGl0c1VzZWQ6IHJlc3BvbnNlLmRhdGEuY3JlZGl0c1VzZWQsXG4gICAgICAgICAgbmV4dDogZ2V0QWxsRGF0YSA/IHZvaWQgMCA6IHJlc3BvbnNlLmRhdGEubmV4dCxcbiAgICAgICAgICBleHBpcmVzQXQ6IG5ldyBEYXRlKHJlc3BvbnNlLmRhdGEuZXhwaXJlc0F0KSxcbiAgICAgICAgICBkYXRhOiBhbGxEYXRhXG4gICAgICAgIH07XG4gICAgICAgIGlmICghcmVzcG9uc2UuZGF0YS5zdWNjZXNzICYmIHJlc3BvbnNlLmRhdGEuZXJyb3IpIHtcbiAgICAgICAgICByZXNwID0ge1xuICAgICAgICAgICAgLi4ucmVzcCxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IHJlc3BvbnNlLmRhdGEuZXJyb3JcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNwb25zZS5kYXRhLm5leHQpIHtcbiAgICAgICAgICByZXNwLm5leHQgPSByZXNwb25zZS5kYXRhLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZUVycm9yKHJlc3BvbnNlLCBcImNoZWNrIGJhdGNoIHNjcmFwZSBzdGF0dXNcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDApO1xuICAgIH1cbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiSW50ZXJuYWwgc2VydmVyIGVycm9yLlwiIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgYmF0Y2ggc2NyYXBlIGVycm9ycy5cbiAgICogQHBhcmFtIGlkIC0gVGhlIElEIG9mIHRoZSBiYXRjaCBzY3JhcGUgb3BlcmF0aW9uLlxuICAgKiBAcmV0dXJucyBJbmZvcm1hdGlvbiBhYm91dCBiYXRjaCBzY3JhcGUgZXJyb3JzLlxuICAgKi9cbiAgYXN5bmMgY2hlY2tCYXRjaFNjcmFwZUVycm9ycyhpZCkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnByZXBhcmVIZWFkZXJzKCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5kZWxldGVSZXF1ZXN0KFxuICAgICAgICBgJHt0aGlzLmFwaVVybH0vdjEvYmF0Y2gvc2NyYXBlLyR7aWR9L2Vycm9yc2AsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgICk7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZUVycm9yKHJlc3BvbnNlLCBcImNoZWNrIGJhdGNoIHNjcmFwZSBlcnJvcnNcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDApO1xuICAgIH1cbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiSW50ZXJuYWwgc2VydmVyIGVycm9yLlwiIH07XG4gIH1cbiAgLyoqXG4gICAqIEV4dHJhY3RzIGluZm9ybWF0aW9uIGZyb20gVVJMcyB1c2luZyB0aGUgRmlyZWNyYXdsIEFQSS5cbiAgICogQ3VycmVudGx5IGluIEJldGEuIEV4cGVjdCBicmVha2luZyBjaGFuZ2VzIG9uIGZ1dHVyZSBtaW5vciB2ZXJzaW9ucy5cbiAgICogQHBhcmFtIHVybHMgLSBUaGUgVVJMcyB0byBleHRyYWN0IGluZm9ybWF0aW9uIGZyb20uIE9wdGlvbmFsIGlmIHVzaW5nIG90aGVyIG1ldGhvZHMgZm9yIGRhdGEgZXh0cmFjdGlvbi5cbiAgICogQHBhcmFtIHBhcmFtcyAtIEFkZGl0aW9uYWwgcGFyYW1ldGVycyBmb3IgdGhlIGV4dHJhY3QgcmVxdWVzdC5cbiAgICogQHJldHVybnMgVGhlIHJlc3BvbnNlIGZyb20gdGhlIGV4dHJhY3Qgb3BlcmF0aW9uLlxuICAgKi9cbiAgYXN5bmMgZXh0cmFjdCh1cmxzLCBwYXJhbXMpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5wcmVwYXJlSGVhZGVycygpO1xuICAgIGxldCBqc29uRGF0YSA9IHsgdXJscywgLi4ucGFyYW1zIH07XG4gICAgbGV0IGpzb25TY2hlbWE7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghcGFyYW1zPy5zY2hlbWEpIHtcbiAgICAgICAganNvblNjaGVtYSA9IHZvaWQgMDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtcy5zY2hlbWEgPT09IFwib2JqZWN0XCIgJiYgcGFyYW1zLnNjaGVtYSAhPT0gbnVsbCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YocGFyYW1zLnNjaGVtYSk/LmNvbnN0cnVjdG9yPy5uYW1lPy5zdGFydHNXaXRoKFwiWm9kXCIpKSB7XG4gICAgICAgIGpzb25TY2hlbWEgPSB6b2RUb0pzb25TY2hlbWEocGFyYW1zLnNjaGVtYSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqc29uU2NoZW1hID0gcGFyYW1zLnNjaGVtYTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKFwiSW52YWxpZCBzY2hlbWEuIFNjaGVtYSBtdXN0IGJlIGVpdGhlciBhIHZhbGlkIFpvZCBzY2hlbWEgb3IgSlNPTiBzY2hlbWEgb2JqZWN0LlwiLCA0MDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnBvc3RSZXF1ZXN0KFxuICAgICAgICB0aGlzLmFwaVVybCArIGAvdjEvZXh0cmFjdGAsXG4gICAgICAgIHsgLi4uanNvbkRhdGEsIHNjaGVtYToganNvblNjaGVtYSwgb3JpZ2luOiBwYXJhbXM/Lm9yaWdpbiB8fCBcImFwaS1zZGtcIiB9LFxuICAgICAgICBoZWFkZXJzXG4gICAgICApO1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIGNvbnN0IGpvYklkID0gcmVzcG9uc2UuZGF0YS5pZDtcbiAgICAgICAgbGV0IGV4dHJhY3RTdGF0dXM7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBjb25zdCBzdGF0dXNSZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0UmVxdWVzdChcbiAgICAgICAgICAgIGAke3RoaXMuYXBpVXJsfS92MS9leHRyYWN0LyR7am9iSWR9YCxcbiAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICApO1xuICAgICAgICAgIGV4dHJhY3RTdGF0dXMgPSBzdGF0dXNSZXNwb25zZS5kYXRhO1xuICAgICAgICAgIGlmIChleHRyYWN0U3RhdHVzLnN0YXR1cyA9PT0gXCJjb21wbGV0ZWRcIikge1xuICAgICAgICAgICAgaWYgKGV4dHJhY3RTdGF0dXMuc3VjY2Vzcykge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YTogZXh0cmFjdFN0YXR1cy5kYXRhLFxuICAgICAgICAgICAgICAgIHdhcm5pbmc6IGV4dHJhY3RTdGF0dXMud2FybmluZyxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXh0cmFjdFN0YXR1cy5lcnJvcixcbiAgICAgICAgICAgICAgICBzb3VyY2VzOiBleHRyYWN0U3RhdHVzPy5zb3VyY2VzIHx8IHZvaWQgMFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGBGYWlsZWQgdG8gZXh0cmFjdCBkYXRhLiBFcnJvcjogJHtleHRyYWN0U3RhdHVzLmVycm9yfWAsIHN0YXR1c1Jlc3BvbnNlLnN0YXR1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChleHRyYWN0U3RhdHVzLnN0YXR1cyA9PT0gXCJmYWlsZWRcIiB8fCBleHRyYWN0U3RhdHVzLnN0YXR1cyA9PT0gXCJjYW5jZWxsZWRcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGBFeHRyYWN0IGpvYiAke2V4dHJhY3RTdGF0dXMuc3RhdHVzfS4gRXJyb3I6ICR7ZXh0cmFjdFN0YXR1cy5lcnJvcn1gLCBzdGF0dXNSZXNwb25zZS5zdGF0dXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxZTMpKTtcbiAgICAgICAgfSB3aGlsZSAoZXh0cmFjdFN0YXR1cy5zdGF0dXMgIT09IFwiY29tcGxldGVkXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihyZXNwb25zZSwgXCJleHRyYWN0XCIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoZXJyb3IubWVzc2FnZSwgNTAwLCBlcnJvci5yZXNwb25zZT8uZGF0YT8uZGV0YWlscyk7XG4gICAgfVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJJbnRlcm5hbCBzZXJ2ZXIgZXJyb3IuXCIgfTtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhdGVzIGFuIGFzeW5jaHJvbm91cyBleHRyYWN0IGpvYiBmb3IgYSBVUkwgdXNpbmcgdGhlIEZpcmVjcmF3bCBBUEkuXG4gICAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIHRvIGV4dHJhY3QgZGF0YSBmcm9tLlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gQWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZvciB0aGUgZXh0cmFjdCByZXF1ZXN0LlxuICAgKiBAcGFyYW0gaWRlbXBvdGVuY3lLZXkgLSBPcHRpb25hbCBpZGVtcG90ZW5jeSBrZXkgZm9yIHRoZSByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgZXh0cmFjdCBvcGVyYXRpb24uXG4gICAqL1xuICBhc3luYyBhc3luY0V4dHJhY3QodXJscywgcGFyYW1zLCBpZGVtcG90ZW5jeUtleSkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnByZXBhcmVIZWFkZXJzKGlkZW1wb3RlbmN5S2V5KTtcbiAgICBsZXQganNvbkRhdGEgPSB7IHVybHMsIC4uLnBhcmFtcyB9O1xuICAgIGxldCBqc29uU2NoZW1hO1xuICAgIHRyeSB7XG4gICAgICBpZiAocGFyYW1zPy5zY2hlbWEgaW5zdGFuY2VvZiB6dC5ab2RUeXBlKSB7XG4gICAgICAgIGpzb25TY2hlbWEgPSB6b2RUb0pzb25TY2hlbWEocGFyYW1zLnNjaGVtYSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqc29uU2NoZW1hID0gcGFyYW1zPy5zY2hlbWE7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihcIkludmFsaWQgc2NoZW1hLiBTY2hlbWEgbXVzdCBiZSBlaXRoZXIgYSB2YWxpZCBab2Qgc2NoZW1hIG9yIEpTT04gc2NoZW1hIG9iamVjdC5cIiwgNDAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wb3N0UmVxdWVzdChcbiAgICAgICAgdGhpcy5hcGlVcmwgKyBgL3YxL2V4dHJhY3RgLFxuICAgICAgICB7IC4uLmpzb25EYXRhLCBzY2hlbWE6IGpzb25TY2hlbWEgfSxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgKTtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IocmVzcG9uc2UsIFwic3RhcnQgZXh0cmFjdCBqb2JcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDAsIGVycm9yLnJlc3BvbnNlPy5kYXRhPy5kZXRhaWxzKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIkludGVybmFsIHNlcnZlciBlcnJvci5cIiB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIHN0YXR1cyBvZiBhbiBleHRyYWN0IGpvYi5cbiAgICogQHBhcmFtIGpvYklkIC0gVGhlIElEIG9mIHRoZSBleHRyYWN0IGpvYi5cbiAgICogQHJldHVybnMgVGhlIHN0YXR1cyBvZiB0aGUgZXh0cmFjdCBqb2IuXG4gICAqL1xuICBhc3luYyBnZXRFeHRyYWN0U3RhdHVzKGpvYklkKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXRSZXF1ZXN0KFxuICAgICAgICBgJHt0aGlzLmFwaVVybH0vdjEvZXh0cmFjdC8ke2pvYklkfWAsXG4gICAgICAgIHRoaXMucHJlcGFyZUhlYWRlcnMoKVxuICAgICAgKTtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IocmVzcG9uc2UsIFwiZ2V0IGV4dHJhY3Qgc3RhdHVzXCIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoZXJyb3IubWVzc2FnZSwgNTAwKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFByZXBhcmVzIHRoZSBoZWFkZXJzIGZvciBhbiBBUEkgcmVxdWVzdC5cbiAgICogQHBhcmFtIGlkZW1wb3RlbmN5S2V5IC0gT3B0aW9uYWwga2V5IHRvIGVuc3VyZSBpZGVtcG90ZW5jeS5cbiAgICogQHJldHVybnMgVGhlIHByZXBhcmVkIGhlYWRlcnMuXG4gICAqL1xuICBwcmVwYXJlSGVhZGVycyhpZGVtcG90ZW5jeUtleSkge1xuICAgIHJldHVybiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0aGlzLmFwaUtleX1gLFxuICAgICAgLi4uaWRlbXBvdGVuY3lLZXkgPyB7IFwieC1pZGVtcG90ZW5jeS1rZXlcIjogaWRlbXBvdGVuY3lLZXkgfSA6IHt9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU2VuZHMgYSBQT1NUIHJlcXVlc3QgdG8gdGhlIHNwZWNpZmllZCBVUkwuXG4gICAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIHRvIHNlbmQgdGhlIHJlcXVlc3QgdG8uXG4gICAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gc2VuZCBpbiB0aGUgcmVxdWVzdC5cbiAgICogQHBhcmFtIGhlYWRlcnMgLSBUaGUgaGVhZGVycyBmb3IgdGhlIHJlcXVlc3QuXG4gICAqIEByZXR1cm5zIFRoZSByZXNwb25zZSBmcm9tIHRoZSBQT1NUIHJlcXVlc3QuXG4gICAqL1xuICBwb3N0UmVxdWVzdCh1cmwsIGRhdGEsIGhlYWRlcnMpIHtcbiAgICByZXR1cm4gYXhpb3MucG9zdCh1cmwsIGRhdGEsIHsgaGVhZGVycywgdGltZW91dDogZGF0YT8udGltZW91dCA/IGRhdGEudGltZW91dCArIDVlMyA6IHZvaWQgMCB9KTtcbiAgfVxuICAvKipcbiAgICogU2VuZHMgYSBHRVQgcmVxdWVzdCB0byB0aGUgc3BlY2lmaWVkIFVSTC5cbiAgICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdG8gc2VuZCB0aGUgcmVxdWVzdCB0by5cbiAgICogQHBhcmFtIGhlYWRlcnMgLSBUaGUgaGVhZGVycyBmb3IgdGhlIHJlcXVlc3QuXG4gICAqIEByZXR1cm5zIFRoZSByZXNwb25zZSBmcm9tIHRoZSBHRVQgcmVxdWVzdC5cbiAgICovXG4gIGFzeW5jIGdldFJlcXVlc3QodXJsLCBoZWFkZXJzKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBheGlvcy5nZXQodXJsLCB7IGhlYWRlcnMgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEF4aW9zRXJyb3IgJiYgZXJyb3IucmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yLnJlc3BvbnNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZW5kcyBhIERFTEVURSByZXF1ZXN0IHRvIHRoZSBzcGVjaWZpZWQgVVJMLlxuICAgKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0byBzZW5kIHRoZSByZXF1ZXN0IHRvLlxuICAgKiBAcGFyYW0gaGVhZGVycyAtIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdC5cbiAgICogQHJldHVybnMgVGhlIHJlc3BvbnNlIGZyb20gdGhlIERFTEVURSByZXF1ZXN0LlxuICAgKi9cbiAgYXN5bmMgZGVsZXRlUmVxdWVzdCh1cmwsIGhlYWRlcnMpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGF4aW9zLmRlbGV0ZSh1cmwsIHsgaGVhZGVycyB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQXhpb3NFcnJvciAmJiBlcnJvci5yZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gZXJyb3IucmVzcG9uc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE1vbml0b3JzIHRoZSBzdGF0dXMgb2YgYSBjcmF3bCBqb2IgdW50aWwgY29tcGxldGlvbiBvciBmYWlsdXJlLlxuICAgKiBAcGFyYW0gaWQgLSBUaGUgSUQgb2YgdGhlIGNyYXdsIG9wZXJhdGlvbi5cbiAgICogQHBhcmFtIGhlYWRlcnMgLSBUaGUgaGVhZGVycyBmb3IgdGhlIHJlcXVlc3QuXG4gICAqIEBwYXJhbSBjaGVja0ludGVydmFsIC0gSW50ZXJ2YWwgaW4gc2Vjb25kcyBmb3Igam9iIHN0YXR1cyBjaGVja3MuXG4gICAqIEBwYXJhbSBjaGVja1VybCAtIE9wdGlvbmFsIFVSTCB0byBjaGVjayB0aGUgc3RhdHVzICh1c2VkIGZvciB2MSBBUEkpXG4gICAqIEByZXR1cm5zIFRoZSBmaW5hbCBqb2Igc3RhdHVzIG9yIGRhdGEuXG4gICAqL1xuICBhc3luYyBtb25pdG9ySm9iU3RhdHVzKGlkLCBoZWFkZXJzLCBjaGVja0ludGVydmFsKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBmYWlsZWRUcmllcyA9IDA7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZXQgc3RhdHVzUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldFJlcXVlc3QoXG4gICAgICAgICAgYCR7dGhpcy5hcGlVcmx9L3YxL2NyYXdsLyR7aWR9YCxcbiAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICk7XG4gICAgICAgIGlmIChzdGF0dXNSZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgIGZhaWxlZFRyaWVzID0gMDtcbiAgICAgICAgICBsZXQgc3RhdHVzRGF0YSA9IHN0YXR1c1Jlc3BvbnNlLmRhdGE7XG4gICAgICAgICAgaWYgKHN0YXR1c0RhdGEuc3RhdHVzID09PSBcImNvbXBsZXRlZFwiKSB7XG4gICAgICAgICAgICBpZiAoXCJkYXRhXCIgaW4gc3RhdHVzRGF0YSkge1xuICAgICAgICAgICAgICBsZXQgZGF0YSA9IHN0YXR1c0RhdGEuZGF0YTtcbiAgICAgICAgICAgICAgd2hpbGUgKHR5cGVvZiBzdGF0dXNEYXRhID09PSBcIm9iamVjdFwiICYmIFwibmV4dFwiIGluIHN0YXR1c0RhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0dXNSZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0UmVxdWVzdChzdGF0dXNEYXRhLm5leHQsIGhlYWRlcnMpO1xuICAgICAgICAgICAgICAgIHN0YXR1c0RhdGEgPSBzdGF0dXNSZXNwb25zZS5kYXRhO1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLmNvbmNhdChzdGF0dXNEYXRhLmRhdGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0YXR1c0RhdGEuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgIHJldHVybiBzdGF0dXNEYXRhO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKFwiQ3Jhd2wgam9iIGNvbXBsZXRlZCBidXQgbm8gZGF0YSB3YXMgcmV0dXJuZWRcIiwgNTAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKFtcImFjdGl2ZVwiLCBcInBhdXNlZFwiLCBcInBlbmRpbmdcIiwgXCJxdWV1ZWRcIiwgXCJ3YWl0aW5nXCIsIFwic2NyYXBpbmdcIl0uaW5jbHVkZXMoc3RhdHVzRGF0YS5zdGF0dXMpKSB7XG4gICAgICAgICAgICBjaGVja0ludGVydmFsID0gTWF0aC5tYXgoY2hlY2tJbnRlcnZhbCwgMik7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShcbiAgICAgICAgICAgICAgKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgY2hlY2tJbnRlcnZhbCAqIDFlMylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihcbiAgICAgICAgICAgICAgYENyYXdsIGpvYiBmYWlsZWQgb3Igd2FzIHN0b3BwZWQuIFN0YXR1czogJHtzdGF0dXNEYXRhLnN0YXR1c31gLFxuICAgICAgICAgICAgICA1MDBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZhaWxlZFRyaWVzKys7XG4gICAgICAgICAgaWYgKGZhaWxlZFRyaWVzID49IDMpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3Ioc3RhdHVzUmVzcG9uc2UsIFwiY2hlY2sgY3Jhd2wgc3RhdHVzXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoZXJyb3IsIDUwMCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIGVycm9ycyBmcm9tIEFQSSByZXNwb25zZXMuXG4gICAqIEBwYXJhbSB7QXhpb3NSZXNwb25zZX0gcmVzcG9uc2UgLSBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uIC0gVGhlIGFjdGlvbiBiZWluZyBwZXJmb3JtZWQgd2hlbiB0aGUgZXJyb3Igb2NjdXJyZWQuXG4gICAqL1xuICBoYW5kbGVFcnJvcihyZXNwb25zZSwgYWN0aW9uKSB7XG4gICAgaWYgKFs0MDAsIDQwMiwgNDAzLCA0MDgsIDQwOSwgNTAwXS5pbmNsdWRlcyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSByZXNwb25zZS5kYXRhLmVycm9yIHx8IFwiVW5rbm93biBlcnJvciBvY2N1cnJlZFwiO1xuICAgICAgY29uc3QgZGV0YWlscyA9IHJlc3BvbnNlLmRhdGEuZGV0YWlscyA/IGAgLSAke0pTT04uc3RyaW5naWZ5KHJlc3BvbnNlLmRhdGEuZGV0YWlscyl9YCA6IFwiXCI7XG4gICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gJHthY3Rpb259LiBTdGF0dXMgY29kZTogJHtyZXNwb25zZS5zdGF0dXN9LiBFcnJvcjogJHtlcnJvck1lc3NhZ2V9JHtkZXRhaWxzfWAsXG4gICAgICAgIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgcmVzcG9uc2U/LmRhdGE/LmRldGFpbHNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihcbiAgICAgICAgYFVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWQgd2hpbGUgdHJ5aW5nIHRvICR7YWN0aW9ufS4gU3RhdHVzIGNvZGU6ICR7cmVzcG9uc2Uuc3RhdHVzfWAsXG4gICAgICAgIHJlc3BvbnNlLnN0YXR1c1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYXRlcyBhIGRlZXAgcmVzZWFyY2ggb3BlcmF0aW9uIG9uIGEgZ2l2ZW4gcXVlcnkgYW5kIHBvbGxzIHVudGlsIGNvbXBsZXRpb24uXG4gICAqIEBwYXJhbSBxdWVyeSAtIFRoZSBxdWVyeSB0byByZXNlYXJjaC5cbiAgICogQHBhcmFtIHBhcmFtcyAtIFBhcmFtZXRlcnMgZm9yIHRoZSBkZWVwIHJlc2VhcmNoIG9wZXJhdGlvbi5cbiAgICogQHBhcmFtIG9uQWN0aXZpdHkgLSBPcHRpb25hbCBjYWxsYmFjayB0byByZWNlaXZlIGFjdGl2aXR5IHVwZGF0ZXMgaW4gcmVhbC10aW1lLlxuICAgKiBAcGFyYW0gb25Tb3VyY2UgLSBPcHRpb25hbCBjYWxsYmFjayB0byByZWNlaXZlIHNvdXJjZSB1cGRhdGVzIGluIHJlYWwtdGltZS5cbiAgICogQHJldHVybnMgVGhlIGZpbmFsIHJlc2VhcmNoIHJlc3VsdHMuXG4gICAqL1xuICBhc3luYyBkZWVwUmVzZWFyY2gocXVlcnksIHBhcmFtcywgb25BY3Rpdml0eSwgb25Tb3VyY2UpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFzeW5jRGVlcFJlc2VhcmNoKHF1ZXJ5LCBwYXJhbXMpO1xuICAgICAgaWYgKCFyZXNwb25zZS5zdWNjZXNzIHx8IFwiZXJyb3JcIiBpbiByZXNwb25zZSkge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiZXJyb3JcIiBpbiByZXNwb25zZSA/IHJlc3BvbnNlLmVycm9yIDogXCJVbmtub3duIGVycm9yXCIgfTtcbiAgICAgIH1cbiAgICAgIGlmICghcmVzcG9uc2UuaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGBGYWlsZWQgdG8gc3RhcnQgcmVzZWFyY2guIE5vIGpvYiBJRCByZXR1cm5lZC5gLCA1MDApO1xuICAgICAgfVxuICAgICAgY29uc3Qgam9iSWQgPSByZXNwb25zZS5pZDtcbiAgICAgIGxldCByZXNlYXJjaFN0YXR1cztcbiAgICAgIGxldCBsYXN0QWN0aXZpdHlDb3VudCA9IDA7XG4gICAgICBsZXQgbGFzdFNvdXJjZUNvdW50ID0gMDtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHJlc2VhcmNoU3RhdHVzID0gYXdhaXQgdGhpcy5jaGVja0RlZXBSZXNlYXJjaFN0YXR1cyhqb2JJZCk7XG4gICAgICAgIGlmIChcImVycm9yXCIgaW4gcmVzZWFyY2hTdGF0dXMgJiYgIXJlc2VhcmNoU3RhdHVzLnN1Y2Nlc3MpIHtcbiAgICAgICAgICByZXR1cm4gcmVzZWFyY2hTdGF0dXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uQWN0aXZpdHkgJiYgcmVzZWFyY2hTdGF0dXMuYWN0aXZpdGllcykge1xuICAgICAgICAgIGNvbnN0IG5ld0FjdGl2aXRpZXMgPSByZXNlYXJjaFN0YXR1cy5hY3Rpdml0aWVzLnNsaWNlKGxhc3RBY3Rpdml0eUNvdW50KTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGFjdGl2aXR5IG9mIG5ld0FjdGl2aXRpZXMpIHtcbiAgICAgICAgICAgIG9uQWN0aXZpdHkoYWN0aXZpdHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsYXN0QWN0aXZpdHlDb3VudCA9IHJlc2VhcmNoU3RhdHVzLmFjdGl2aXRpZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvblNvdXJjZSAmJiByZXNlYXJjaFN0YXR1cy5zb3VyY2VzKSB7XG4gICAgICAgICAgY29uc3QgbmV3U291cmNlcyA9IHJlc2VhcmNoU3RhdHVzLnNvdXJjZXMuc2xpY2UobGFzdFNvdXJjZUNvdW50KTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBuZXdTb3VyY2VzKSB7XG4gICAgICAgICAgICBvblNvdXJjZShzb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsYXN0U291cmNlQ291bnQgPSByZXNlYXJjaFN0YXR1cy5zb3VyY2VzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzZWFyY2hTdGF0dXMuc3RhdHVzID09PSBcImNvbXBsZXRlZFwiKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc2VhcmNoU3RhdHVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNlYXJjaFN0YXR1cy5zdGF0dXMgPT09IFwiZmFpbGVkXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoXG4gICAgICAgICAgICBgUmVzZWFyY2ggam9iICR7cmVzZWFyY2hTdGF0dXMuc3RhdHVzfS4gRXJyb3I6ICR7cmVzZWFyY2hTdGF0dXMuZXJyb3J9YCxcbiAgICAgICAgICAgIDUwMFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc2VhcmNoU3RhdHVzLnN0YXR1cyAhPT0gXCJwcm9jZXNzaW5nXCIpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyZTMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJSZXNlYXJjaCBqb2IgdGVybWluYXRlZCB1bmV4cGVjdGVkbHlcIiB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoZXJyb3IubWVzc2FnZSwgNTAwLCBlcnJvci5yZXNwb25zZT8uZGF0YT8uZGV0YWlscyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJbml0aWF0ZXMgYSBkZWVwIHJlc2VhcmNoIG9wZXJhdGlvbiBvbiBhIGdpdmVuIHF1ZXJ5IHdpdGhvdXQgcG9sbGluZy5cbiAgICogQHBhcmFtIHBhcmFtcyAtIFBhcmFtZXRlcnMgZm9yIHRoZSBkZWVwIHJlc2VhcmNoIG9wZXJhdGlvbi5cbiAgICogQHJldHVybnMgVGhlIHJlc3BvbnNlIGNvbnRhaW5pbmcgdGhlIHJlc2VhcmNoIGpvYiBJRC5cbiAgICovXG4gIGFzeW5jIGFzeW5jRGVlcFJlc2VhcmNoKHF1ZXJ5LCBwYXJhbXMpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5wcmVwYXJlSGVhZGVycygpO1xuICAgIGxldCBqc29uRGF0YSA9IHsgcXVlcnksIC4uLnBhcmFtcyB9O1xuICAgIGlmIChqc29uRGF0YT8uanNvbk9wdGlvbnM/LnNjaGVtYSkge1xuICAgICAgbGV0IHNjaGVtYSA9IGpzb25EYXRhLmpzb25PcHRpb25zLnNjaGVtYTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNjaGVtYSA9IHpvZFRvSnNvblNjaGVtYShzY2hlbWEpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIH1cbiAgICAgIGpzb25EYXRhID0ge1xuICAgICAgICAuLi5qc29uRGF0YSxcbiAgICAgICAganNvbk9wdGlvbnM6IHtcbiAgICAgICAgICAuLi5qc29uRGF0YS5qc29uT3B0aW9ucyxcbiAgICAgICAgICBzY2hlbWFcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wb3N0UmVxdWVzdChcbiAgICAgICAgYCR7dGhpcy5hcGlVcmx9L3YxL2RlZXAtcmVzZWFyY2hgLFxuICAgICAgICBqc29uRGF0YSxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgKTtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IocmVzcG9uc2UsIFwic3RhcnQgZGVlcCByZXNlYXJjaFwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yLnJlc3BvbnNlPy5kYXRhPy5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoYFJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJHtlcnJvci5yZXNwb25zZS5zdGF0dXN9LiBFcnJvcjogJHtlcnJvci5yZXNwb25zZS5kYXRhLmVycm9yfSAke2Vycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlscyA/IGAgLSAke0pTT04uc3RyaW5naWZ5KGVycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlscyl9YCA6IFwiXCJ9YCwgZXJyb3IucmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiSW50ZXJuYWwgc2VydmVyIGVycm9yLlwiIH07XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB0aGUgc3RhdHVzIG9mIGEgZGVlcCByZXNlYXJjaCBvcGVyYXRpb24uXG4gICAqIEBwYXJhbSBpZCAtIFRoZSBJRCBvZiB0aGUgZGVlcCByZXNlYXJjaCBvcGVyYXRpb24uXG4gICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHN0YXR1cyBhbmQgcmVzdWx0cyBvZiB0aGUgcmVzZWFyY2ggb3BlcmF0aW9uLlxuICAgKi9cbiAgYXN5bmMgY2hlY2tEZWVwUmVzZWFyY2hTdGF0dXMoaWQpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5wcmVwYXJlSGVhZGVycygpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0UmVxdWVzdChcbiAgICAgICAgYCR7dGhpcy5hcGlVcmx9L3YxL2RlZXAtcmVzZWFyY2gvJHtpZH1gLFxuICAgICAgICBoZWFkZXJzXG4gICAgICApO1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoXCJEZWVwIHJlc2VhcmNoIGpvYiBub3QgZm91bmRcIiwgNDA0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IocmVzcG9uc2UsIFwiY2hlY2sgZGVlcCByZXNlYXJjaCBzdGF0dXNcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5yZXNwb25zZT8uZGF0YT8uZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGBSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICR7ZXJyb3IucmVzcG9uc2Uuc3RhdHVzfS4gRXJyb3I6ICR7ZXJyb3IucmVzcG9uc2UuZGF0YS5lcnJvcn0gJHtlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbHMgPyBgIC0gJHtKU09OLnN0cmluZ2lmeShlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbHMpfWAgOiBcIlwifWAsIGVycm9yLnJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoZXJyb3IubWVzc2FnZSwgNTAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIkludGVybmFsIHNlcnZlciBlcnJvci5cIiB9O1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVlcFJlc2VhcmNoKCkgaW5zdGVhZFxuICAgKiBJbml0aWF0ZXMgYSBkZWVwIHJlc2VhcmNoIG9wZXJhdGlvbiBvbiBhIGdpdmVuIHRvcGljIGFuZCBwb2xscyB1bnRpbCBjb21wbGV0aW9uLlxuICAgKiBAcGFyYW0gdG9waWMgLSBUaGUgdG9waWMgdG8gcmVzZWFyY2guXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBQYXJhbWV0ZXJzIGZvciB0aGUgZGVlcCByZXNlYXJjaCBvcGVyYXRpb24uXG4gICAqIEBwYXJhbSBvbkFjdGl2aXR5IC0gT3B0aW9uYWwgY2FsbGJhY2sgdG8gcmVjZWl2ZSBhY3Rpdml0eSB1cGRhdGVzIGluIHJlYWwtdGltZS5cbiAgICogQHJldHVybnMgVGhlIGZpbmFsIHJlc2VhcmNoIHJlc3VsdHMuXG4gICAqL1xuICBhc3luYyBfX2RlZXBSZXNlYXJjaCh0b3BpYywgcGFyYW1zLCBvbkFjdGl2aXR5KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fX2FzeW5jRGVlcFJlc2VhcmNoKHRvcGljLCBwYXJhbXMpO1xuICAgICAgaWYgKCFyZXNwb25zZS5zdWNjZXNzIHx8IFwiZXJyb3JcIiBpbiByZXNwb25zZSkge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiZXJyb3JcIiBpbiByZXNwb25zZSA/IHJlc3BvbnNlLmVycm9yIDogXCJVbmtub3duIGVycm9yXCIgfTtcbiAgICAgIH1cbiAgICAgIGlmICghcmVzcG9uc2UuaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGBGYWlsZWQgdG8gc3RhcnQgcmVzZWFyY2guIE5vIGpvYiBJRCByZXR1cm5lZC5gLCA1MDApO1xuICAgICAgfVxuICAgICAgY29uc3Qgam9iSWQgPSByZXNwb25zZS5pZDtcbiAgICAgIGxldCByZXNlYXJjaFN0YXR1cztcbiAgICAgIGxldCBsYXN0QWN0aXZpdHlDb3VudCA9IDA7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICByZXNlYXJjaFN0YXR1cyA9IGF3YWl0IHRoaXMuX19jaGVja0RlZXBSZXNlYXJjaFN0YXR1cyhqb2JJZCk7XG4gICAgICAgIGlmIChcImVycm9yXCIgaW4gcmVzZWFyY2hTdGF0dXMgJiYgIXJlc2VhcmNoU3RhdHVzLnN1Y2Nlc3MpIHtcbiAgICAgICAgICByZXR1cm4gcmVzZWFyY2hTdGF0dXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uQWN0aXZpdHkgJiYgcmVzZWFyY2hTdGF0dXMuYWN0aXZpdGllcykge1xuICAgICAgICAgIGNvbnN0IG5ld0FjdGl2aXRpZXMgPSByZXNlYXJjaFN0YXR1cy5hY3Rpdml0aWVzLnNsaWNlKGxhc3RBY3Rpdml0eUNvdW50KTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGFjdGl2aXR5IG9mIG5ld0FjdGl2aXRpZXMpIHtcbiAgICAgICAgICAgIG9uQWN0aXZpdHkoYWN0aXZpdHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsYXN0QWN0aXZpdHlDb3VudCA9IHJlc2VhcmNoU3RhdHVzLmFjdGl2aXRpZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNlYXJjaFN0YXR1cy5zdGF0dXMgPT09IFwiY29tcGxldGVkXCIpIHtcbiAgICAgICAgICByZXR1cm4gcmVzZWFyY2hTdGF0dXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc2VhcmNoU3RhdHVzLnN0YXR1cyA9PT0gXCJmYWlsZWRcIikge1xuICAgICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihcbiAgICAgICAgICAgIGBSZXNlYXJjaCBqb2IgJHtyZXNlYXJjaFN0YXR1cy5zdGF0dXN9LiBFcnJvcjogJHtyZXNlYXJjaFN0YXR1cy5lcnJvcn1gLFxuICAgICAgICAgICAgNTAwXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzZWFyY2hTdGF0dXMuc3RhdHVzICE9PSBcInByb2Nlc3NpbmdcIikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDJlMykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIlJlc2VhcmNoIGpvYiB0ZXJtaW5hdGVkIHVuZXhwZWN0ZWRseVwiIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDAsIGVycm9yLnJlc3BvbnNlPy5kYXRhPy5kZXRhaWxzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBhc3luY0RlZXBSZXNlYXJjaCgpIGluc3RlYWRcbiAgICogSW5pdGlhdGVzIGEgZGVlcCByZXNlYXJjaCBvcGVyYXRpb24gb24gYSBnaXZlbiB0b3BpYyB3aXRob3V0IHBvbGxpbmcuXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBQYXJhbWV0ZXJzIGZvciB0aGUgZGVlcCByZXNlYXJjaCBvcGVyYXRpb24uXG4gICAqIEByZXR1cm5zIFRoZSByZXNwb25zZSBjb250YWluaW5nIHRoZSByZXNlYXJjaCBqb2IgSUQuXG4gICAqL1xuICBhc3luYyBfX2FzeW5jRGVlcFJlc2VhcmNoKHRvcGljLCBwYXJhbXMpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5wcmVwYXJlSGVhZGVycygpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucG9zdFJlcXVlc3QoXG4gICAgICAgIGAke3RoaXMuYXBpVXJsfS92MS9kZWVwLXJlc2VhcmNoYCxcbiAgICAgICAgeyB0b3BpYywgLi4ucGFyYW1zIH0sXG4gICAgICAgIGhlYWRlcnNcbiAgICAgICk7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZUVycm9yKHJlc3BvbnNlLCBcInN0YXJ0IGRlZXAgcmVzZWFyY2hcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5yZXNwb25zZT8uZGF0YT8uZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGBSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICR7ZXJyb3IucmVzcG9uc2Uuc3RhdHVzfS4gRXJyb3I6ICR7ZXJyb3IucmVzcG9uc2UuZGF0YS5lcnJvcn0gJHtlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbHMgPyBgIC0gJHtKU09OLnN0cmluZ2lmeShlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbHMpfWAgOiBcIlwifWAsIGVycm9yLnJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoZXJyb3IubWVzc2FnZSwgNTAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIkludGVybmFsIHNlcnZlciBlcnJvci5cIiB9O1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY2hlY2tEZWVwUmVzZWFyY2hTdGF0dXMoKSBpbnN0ZWFkXG4gICAqIENoZWNrcyB0aGUgc3RhdHVzIG9mIGEgZGVlcCByZXNlYXJjaCBvcGVyYXRpb24uXG4gICAqIEBwYXJhbSBpZCAtIFRoZSBJRCBvZiB0aGUgZGVlcCByZXNlYXJjaCBvcGVyYXRpb24uXG4gICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHN0YXR1cyBhbmQgcmVzdWx0cyBvZiB0aGUgcmVzZWFyY2ggb3BlcmF0aW9uLlxuICAgKi9cbiAgYXN5bmMgX19jaGVja0RlZXBSZXNlYXJjaFN0YXR1cyhpZCkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnByZXBhcmVIZWFkZXJzKCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXRSZXF1ZXN0KFxuICAgICAgICBgJHt0aGlzLmFwaVVybH0vdjEvZGVlcC1yZXNlYXJjaC8ke2lkfWAsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgICk7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihcIkRlZXAgcmVzZWFyY2ggam9iIG5vdCBmb3VuZFwiLCA0MDQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihyZXNwb25zZSwgXCJjaGVjayBkZWVwIHJlc2VhcmNoIHN0YXR1c1wiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yLnJlc3BvbnNlPy5kYXRhPy5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoYFJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJHtlcnJvci5yZXNwb25zZS5zdGF0dXN9LiBFcnJvcjogJHtlcnJvci5yZXNwb25zZS5kYXRhLmVycm9yfSAke2Vycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlscyA/IGAgLSAke0pTT04uc3RyaW5naWZ5KGVycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlscyl9YCA6IFwiXCJ9YCwgZXJyb3IucmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiSW50ZXJuYWwgc2VydmVyIGVycm9yLlwiIH07XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBMTE1zLnR4dCBmb3IgYSBnaXZlbiBVUkwgYW5kIHBvbGxzIHVudGlsIGNvbXBsZXRpb24uXG4gICAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIHRvIGdlbmVyYXRlIExMTXMudHh0IGZyb20uXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBQYXJhbWV0ZXJzIGZvciB0aGUgTExNcy50eHQgZ2VuZXJhdGlvbiBvcGVyYXRpb24uXG4gICAqIEByZXR1cm5zIFRoZSBmaW5hbCBnZW5lcmF0aW9uIHJlc3VsdHMuXG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZUxMTXNUZXh0KHVybCwgcGFyYW1zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hc3luY0dlbmVyYXRlTExNc1RleHQodXJsLCBwYXJhbXMpO1xuICAgICAgaWYgKCFyZXNwb25zZS5zdWNjZXNzIHx8IFwiZXJyb3JcIiBpbiByZXNwb25zZSkge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiZXJyb3JcIiBpbiByZXNwb25zZSA/IHJlc3BvbnNlLmVycm9yIDogXCJVbmtub3duIGVycm9yXCIgfTtcbiAgICAgIH1cbiAgICAgIGlmICghcmVzcG9uc2UuaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGBGYWlsZWQgdG8gc3RhcnQgTExNcy50eHQgZ2VuZXJhdGlvbi4gTm8gam9iIElEIHJldHVybmVkLmAsIDUwMCk7XG4gICAgICB9XG4gICAgICBjb25zdCBqb2JJZCA9IHJlc3BvbnNlLmlkO1xuICAgICAgbGV0IGdlbmVyYXRpb25TdGF0dXM7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBnZW5lcmF0aW9uU3RhdHVzID0gYXdhaXQgdGhpcy5jaGVja0dlbmVyYXRlTExNc1RleHRTdGF0dXMoam9iSWQpO1xuICAgICAgICBpZiAoXCJlcnJvclwiIGluIGdlbmVyYXRpb25TdGF0dXMgJiYgIWdlbmVyYXRpb25TdGF0dXMuc3VjY2Vzcykge1xuICAgICAgICAgIHJldHVybiBnZW5lcmF0aW9uU3RhdHVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZW5lcmF0aW9uU3RhdHVzLnN0YXR1cyA9PT0gXCJjb21wbGV0ZWRcIikge1xuICAgICAgICAgIHJldHVybiBnZW5lcmF0aW9uU3RhdHVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZW5lcmF0aW9uU3RhdHVzLnN0YXR1cyA9PT0gXCJmYWlsZWRcIikge1xuICAgICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihcbiAgICAgICAgICAgIGBMTE1zLnR4dCBnZW5lcmF0aW9uIGpvYiAke2dlbmVyYXRpb25TdGF0dXMuc3RhdHVzfS4gRXJyb3I6ICR7Z2VuZXJhdGlvblN0YXR1cy5lcnJvcn1gLFxuICAgICAgICAgICAgNTAwXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2VuZXJhdGlvblN0YXR1cy5zdGF0dXMgIT09IFwicHJvY2Vzc2luZ1wiKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMmUzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiTExNcy50eHQgZ2VuZXJhdGlvbiBqb2IgdGVybWluYXRlZCB1bmV4cGVjdGVkbHlcIiB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoZXJyb3IubWVzc2FnZSwgNTAwLCBlcnJvci5yZXNwb25zZT8uZGF0YT8uZGV0YWlscyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJbml0aWF0ZXMgYSBMTE1zLnR4dCBnZW5lcmF0aW9uIG9wZXJhdGlvbiB3aXRob3V0IHBvbGxpbmcuXG4gICAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIHRvIGdlbmVyYXRlIExMTXMudHh0IGZyb20uXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBQYXJhbWV0ZXJzIGZvciB0aGUgTExNcy50eHQgZ2VuZXJhdGlvbiBvcGVyYXRpb24uXG4gICAqIEByZXR1cm5zIFRoZSByZXNwb25zZSBjb250YWluaW5nIHRoZSBnZW5lcmF0aW9uIGpvYiBJRC5cbiAgICovXG4gIGFzeW5jIGFzeW5jR2VuZXJhdGVMTE1zVGV4dCh1cmwsIHBhcmFtcykge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnByZXBhcmVIZWFkZXJzKCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wb3N0UmVxdWVzdChcbiAgICAgICAgYCR7dGhpcy5hcGlVcmx9L3YxL2xsbXN0eHRgLFxuICAgICAgICB7IHVybCwgLi4ucGFyYW1zIH0sXG4gICAgICAgIGhlYWRlcnNcbiAgICAgICk7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZUVycm9yKHJlc3BvbnNlLCBcInN0YXJ0IExMTXMudHh0IGdlbmVyYXRpb25cIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5yZXNwb25zZT8uZGF0YT8uZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGBSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICR7ZXJyb3IucmVzcG9uc2Uuc3RhdHVzfS4gRXJyb3I6ICR7ZXJyb3IucmVzcG9uc2UuZGF0YS5lcnJvcn0gJHtlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbHMgPyBgIC0gJHtKU09OLnN0cmluZ2lmeShlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbHMpfWAgOiBcIlwifWAsIGVycm9yLnJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoZXJyb3IubWVzc2FnZSwgNTAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIkludGVybmFsIHNlcnZlciBlcnJvci5cIiB9O1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgdGhlIHN0YXR1cyBvZiBhIExMTXMudHh0IGdlbmVyYXRpb24gb3BlcmF0aW9uLlxuICAgKiBAcGFyYW0gaWQgLSBUaGUgSUQgb2YgdGhlIExMTXMudHh0IGdlbmVyYXRpb24gb3BlcmF0aW9uLlxuICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBzdGF0dXMgYW5kIHJlc3VsdHMgb2YgdGhlIGdlbmVyYXRpb24gb3BlcmF0aW9uLlxuICAgKi9cbiAgYXN5bmMgY2hlY2tHZW5lcmF0ZUxMTXNUZXh0U3RhdHVzKGlkKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHRoaXMucHJlcGFyZUhlYWRlcnMoKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldFJlcXVlc3QoXG4gICAgICAgIGAke3RoaXMuYXBpVXJsfS92MS9sbG1zdHh0LyR7aWR9YCxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgKTtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKFwiTExNcy50eHQgZ2VuZXJhdGlvbiBqb2Igbm90IGZvdW5kXCIsIDQwNCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZUVycm9yKHJlc3BvbnNlLCBcImNoZWNrIExMTXMudHh0IGdlbmVyYXRpb24gc3RhdHVzXCIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IucmVzcG9uc2U/LmRhdGE/LmVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihgUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAke2Vycm9yLnJlc3BvbnNlLnN0YXR1c30uIEVycm9yOiAke2Vycm9yLnJlc3BvbnNlLmRhdGEuZXJyb3J9ICR7ZXJyb3IucmVzcG9uc2UuZGF0YS5kZXRhaWxzID8gYCAtICR7SlNPTi5zdHJpbmdpZnkoZXJyb3IucmVzcG9uc2UuZGF0YS5kZXRhaWxzKX1gIDogXCJcIn1gLCBlcnJvci5yZXNwb25zZS5zdGF0dXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGVycm9yLm1lc3NhZ2UsIDUwMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJJbnRlcm5hbCBzZXJ2ZXIgZXJyb3IuXCIgfTtcbiAgfVxufTtcbnZhciBDcmF3bFdhdGNoZXIgPSBjbGFzcyBleHRlbmRzIFR5cGVkRXZlbnRUYXJnZXQge1xuICB3cztcbiAgZGF0YTtcbiAgc3RhdHVzO1xuICBpZDtcbiAgY29uc3RydWN0b3IoaWQsIGFwcCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIGNvbnN0IHdzVXJsID0gYXBwLmFwaVVybC5yZXBsYWNlKC9eaHR0cC8sIFwid3NcIik7XG4gICAgdGhpcy53cyA9IG5ldyBXZWJTb2NrZXQoYCR7d3NVcmx9L3YxL2NyYXdsLyR7aWR9YCwgYXBwLmFwaUtleSk7XG4gICAgdGhpcy5zdGF0dXMgPSBcInNjcmFwaW5nXCI7XG4gICAgdGhpcy5kYXRhID0gW107XG4gICAgY29uc3QgbWVzc2FnZUhhbmRsZXIgPSAobXNnKSA9PiB7XG4gICAgICBpZiAobXNnLnR5cGUgPT09IFwiZG9uZVwiKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gXCJjb21wbGV0ZWRcIjtcbiAgICAgICAgdGhpcy5kaXNwYXRjaFR5cGVkRXZlbnQoXCJkb25lXCIsIG5ldyBDdXN0b21FdmVudChcImRvbmVcIiwge1xuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkXG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2UgaWYgKG1zZy50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBcImZhaWxlZFwiO1xuICAgICAgICB0aGlzLmRpc3BhdGNoVHlwZWRFdmVudChcImVycm9yXCIsIG5ldyBDdXN0b21FdmVudChcImVycm9yXCIsIHtcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICAgICAgICBlcnJvcjogbXNnLmVycm9yLFxuICAgICAgICAgICAgaWQ6IHRoaXMuaWRcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSBpZiAobXNnLnR5cGUgPT09IFwiY2F0Y2h1cFwiKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gbXNnLmRhdGEuc3RhdHVzO1xuICAgICAgICB0aGlzLmRhdGEucHVzaCguLi5tc2cuZGF0YS5kYXRhID8/IFtdKTtcbiAgICAgICAgZm9yIChjb25zdCBkb2Mgb2YgdGhpcy5kYXRhKSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaFR5cGVkRXZlbnQoXCJkb2N1bWVudFwiLCBuZXcgQ3VzdG9tRXZlbnQoXCJkb2N1bWVudFwiLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgLi4uZG9jLFxuICAgICAgICAgICAgICBpZDogdGhpcy5pZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChtc2cudHlwZSA9PT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hUeXBlZEV2ZW50KFwiZG9jdW1lbnRcIiwgbmV3IEN1c3RvbUV2ZW50KFwiZG9jdW1lbnRcIiwge1xuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgLi4ubXNnLmRhdGEsXG4gICAgICAgICAgICBpZDogdGhpcy5pZFxuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy53cy5vbm1lc3NhZ2UgPSAoKGV2KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGV2LmRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhpcy53cy5jbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBtc2cgPSBKU09OLnBhcnNlKGV2LmRhdGEpO1xuICAgICAgICBtZXNzYWdlSGFuZGxlcihtc2cpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIG9uIG1lc3NhZ2VcIiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pLmJpbmQodGhpcyk7XG4gICAgdGhpcy53cy5vbmNsb3NlID0gKChldikgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbXNnID0gSlNPTi5wYXJzZShldi5yZWFzb24pO1xuICAgICAgICBtZXNzYWdlSGFuZGxlcihtc2cpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIG9uIGNsb3NlXCIsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9KS5iaW5kKHRoaXMpO1xuICAgIHRoaXMud3Mub25lcnJvciA9ICgoXykgPT4ge1xuICAgICAgdGhpcy5zdGF0dXMgPSBcImZhaWxlZFwiO1xuICAgICAgdGhpcy5kaXNwYXRjaFR5cGVkRXZlbnQoXCJlcnJvclwiLCBuZXcgQ3VzdG9tRXZlbnQoXCJlcnJvclwiLCB7XG4gICAgICAgIGRldGFpbDoge1xuICAgICAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICAgICAgZGF0YTogdGhpcy5kYXRhLFxuICAgICAgICAgIGVycm9yOiBcIldlYlNvY2tldCBlcnJvclwiLFxuICAgICAgICAgIGlkOiB0aGlzLmlkXG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9KS5iaW5kKHRoaXMpO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIENyYXdsV2F0Y2hlcixcbiAgRmlyZWNyYXdsRXJyb3IsXG4gIEZpcmVjcmF3bEFwcCBhcyBkZWZhdWx0XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@mendable/firecrawl-js/dist/index.js\n");

/***/ })

};
;